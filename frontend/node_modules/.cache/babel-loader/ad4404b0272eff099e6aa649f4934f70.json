{"ast":null,"code":"/*\n * Utilities: A classic collection of JavaScript utilities\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet fs = require('fs');\n\nlet path = require('path');\n/**\n  @name file\n  @namespace file\n*/\n\n\nlet fileUtils = new function () {\n  // Recursively copy files and directories\n  let _copyFile = function (fromPath, toPath, opts) {\n    let from = path.normalize(fromPath);\n    let to = path.normalize(toPath);\n    let options = opts || {};\n    let fromStat;\n    let toStat;\n    let destExists;\n    let destDoesNotExistErr;\n    let content;\n    let filename;\n    let dirContents;\n    let targetDir;\n    fromStat = fs.statSync(from);\n\n    try {\n      //console.dir(to + ' destExists');\n      toStat = fs.statSync(to);\n      destExists = true;\n    } catch (e) {\n      //console.dir(to + ' does not exist');\n      destDoesNotExistErr = e;\n      destExists = false;\n    } // Destination dir or file exists, copy into (directory)\n    // or overwrite (file)\n\n\n    if (destExists) {\n      // If there's a rename-via-copy file/dir name passed, use it.\n      // Otherwise use the actual file/dir name\n      filename = options.rename || path.basename(from); // Copying a directory\n\n      if (fromStat.isDirectory()) {\n        dirContents = fs.readdirSync(from);\n        targetDir = path.join(to, filename); // We don't care if the target dir already exists\n\n        try {\n          fs.mkdirSync(targetDir, {\n            mode: fromStat.mode & 0o777\n          });\n        } catch (e) {\n          if (e.code !== 'EEXIST') {\n            throw e;\n          }\n        }\n\n        for (let i = 0, ii = dirContents.length; i < ii; i++) {\n          _copyFile(path.join(from, dirContents[i]), targetDir, {\n            preserveMode: options.preserveMode\n          });\n        }\n      } // Copying a file\n      else {\n          content = fs.readFileSync(from);\n          let mode = fromStat.mode & 0o777;\n          let targetFile = to;\n\n          if (toStat.isDirectory()) {\n            targetFile = path.join(to, filename);\n          }\n\n          let fileExists = fs.existsSync(targetFile);\n          fs.writeFileSync(targetFile, content); // If the file didn't already exist, use the original file mode.\n          // Otherwise, only update the mode if preserverMode is true.\n\n          if (!fileExists || options.preserveMode) {\n            fs.chmodSync(targetFile, mode);\n          }\n        }\n    } // Dest doesn't exist, can't create it\n    else {\n        throw destDoesNotExistErr;\n      }\n  }; // Remove the given directory\n\n\n  let _rmDir = function (dirPath) {\n    let dir = path.normalize(dirPath);\n    let paths = [];\n    paths = fs.readdirSync(dir);\n    paths.forEach(function (p) {\n      let curr = path.join(dir, p);\n      let stat = fs.lstatSync(curr);\n\n      if (stat.isDirectory()) {\n        _rmDir(curr);\n      } else {\n        try {\n          fs.unlinkSync(curr);\n        } catch (e) {\n          if (e.code === 'EPERM') {\n            fs.chmodSync(curr, parseInt(666, 8));\n            fs.unlinkSync(curr);\n          } else {\n            throw e;\n          }\n        }\n      }\n    });\n    fs.rmdirSync(dir);\n  };\n  /**\n    @name file#cpR\n    @public\n    @function\n    @description Copies a directory/file to a destination\n    @param {String} fromPath The source path to copy from\n    @param {String} toPath The destination path to copy to\n    @param {Object} opts Options to use\n      @param {Boolean} [opts.preserveMode] If target file already exists, this\n        determines whether the original file's mode is copied over. The default of\n        false mimics the behavior of the `cp` command line tool. (Default: false)\n  */\n\n\n  this.cpR = function (fromPath, toPath, options) {\n    let from = path.normalize(fromPath);\n    let to = path.normalize(toPath);\n    let toStat;\n    let doesNotExistErr;\n    let filename;\n    let opts = options || {};\n\n    if (from == to) {\n      throw new Error('Cannot copy ' + from + ' to itself.');\n    } // Handle rename-via-copy\n\n\n    try {\n      toStat = fs.statSync(to);\n    } catch (e) {\n      doesNotExistErr = e; // Get abs path so it's possible to check parent dir\n\n      if (!this.isAbsolute(to)) {\n        to = path.join(process.cwd(), to);\n      } // Save the file/dir name\n\n\n      filename = path.basename(to); // See if a parent dir exists, so there's a place to put the\n      /// renamed file/dir (resets the destination for the copy)\n\n      to = path.dirname(to);\n\n      try {\n        toStat = fs.statSync(to);\n      } catch (e) {}\n\n      if (toStat && toStat.isDirectory()) {\n        // Set the rename opt to pass to the copy func, will be used\n        // as the new file/dir name\n        opts.rename = filename; //console.log('filename ' + filename);\n      } else {\n        throw doesNotExistErr;\n      }\n    }\n\n    _copyFile(from, to, opts);\n  };\n  /**\n    @name file#mkdirP\n    @public\n    @function\n    @description Create the given directory(ies) using the given mode permissions\n    @param {String} dir The directory to create\n    @param {Number} mode The mode to give the created directory(ies)(Default: 0755)\n  */\n\n\n  this.mkdirP = function (dir, mode) {\n    let dirPath = path.normalize(dir);\n    let paths = dirPath.split(/\\/|\\\\/);\n    let currPath = '';\n    let next;\n\n    if (paths[0] == '' || /^[A-Za-z]+:/.test(paths[0])) {\n      currPath = paths.shift() || '/';\n      currPath = path.join(currPath, paths.shift()); //console.log('basedir');\n    }\n\n    while (next = paths.shift()) {\n      if (next == '..') {\n        currPath = path.join(currPath, next);\n        continue;\n      }\n\n      currPath = path.join(currPath, next);\n\n      try {\n        //console.log('making ' + currPath);\n        fs.mkdirSync(currPath, mode || parseInt(755, 8));\n      } catch (e) {\n        if (e.code != 'EEXIST') {\n          throw e;\n        }\n      }\n    }\n  };\n  /**\n    @name file#rmRf\n    @public\n    @function\n    @description Deletes the given directory/file\n    @param {String} p The path to delete, can be a directory or file\n  */\n\n\n  this.rmRf = function (p, options) {\n    let stat;\n\n    try {\n      stat = fs.lstatSync(p);\n\n      if (stat.isDirectory()) {\n        _rmDir(p);\n      } else {\n        fs.unlinkSync(p);\n      }\n    } catch (e) {}\n  };\n  /**\n    @name file#isAbsolute\n    @public\n    @function\n    @return {Boolean/String} If it's absolute the first character is returned otherwise false\n    @description Checks if a given path is absolute or relative\n    @param {String} p Path to check\n  */\n\n\n  this.isAbsolute = function (p) {\n    let match = /^[A-Za-z]+:\\\\|^\\//.exec(p);\n\n    if (match && match.length) {\n      return match[0];\n    }\n\n    return false;\n  };\n  /**\n    @name file#absolutize\n    @public\n    @function\n    @return {String} Returns the absolute path for the given path\n    @description Returns the absolute path for the given path\n    @param {String} p The path to get the absolute path for\n  */\n\n\n  this.absolutize = function (p) {\n    if (this.isAbsolute(p)) {\n      return p;\n    } else {\n      return path.join(process.cwd(), p);\n    }\n  };\n}();\nmodule.exports = fileUtils;","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/utils/file.js"],"names":["fs","require","path","fileUtils","_copyFile","fromPath","toPath","opts","from","normalize","to","options","fromStat","toStat","destExists","destDoesNotExistErr","content","filename","dirContents","targetDir","statSync","e","rename","basename","isDirectory","readdirSync","join","mkdirSync","mode","code","i","ii","length","preserveMode","readFileSync","targetFile","fileExists","existsSync","writeFileSync","chmodSync","_rmDir","dirPath","dir","paths","forEach","p","curr","stat","lstatSync","unlinkSync","parseInt","rmdirSync","cpR","doesNotExistErr","Error","isAbsolute","process","cwd","dirname","mkdirP","split","currPath","next","test","shift","rmRf","match","exec","absolutize","module","exports"],"mappings":"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","sourcesContent":["/*\n * Utilities: A classic collection of JavaScript utilities\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet fs = require('fs');\nlet path = require('path');\n\n/**\n  @name file\n  @namespace file\n*/\n\nlet fileUtils = new (function () {\n\n  // Recursively copy files and directories\n  let _copyFile = function (fromPath, toPath, opts) {\n    let from = path.normalize(fromPath)\n    let to = path.normalize(toPath)\n    let options = opts || {}\n    let fromStat;\n    let toStat;\n    let destExists;\n    let destDoesNotExistErr;\n    let content;\n    let filename;\n    let dirContents;\n    let targetDir;\n\n    fromStat = fs.statSync(from);\n\n    try {\n      //console.dir(to + ' destExists');\n      toStat = fs.statSync(to);\n      destExists = true;\n    }\n    catch(e) {\n      //console.dir(to + ' does not exist');\n      destDoesNotExistErr = e;\n      destExists = false;\n    }\n    // Destination dir or file exists, copy into (directory)\n    // or overwrite (file)\n    if (destExists) {\n\n      // If there's a rename-via-copy file/dir name passed, use it.\n      // Otherwise use the actual file/dir name\n      filename = options.rename || path.basename(from);\n\n      // Copying a directory\n      if (fromStat.isDirectory()) {\n        dirContents = fs.readdirSync(from);\n        targetDir = path.join(to, filename);\n        // We don't care if the target dir already exists\n        try {\n          fs.mkdirSync(targetDir, {mode: fromStat.mode & 0o777});\n        }\n        catch(e) {\n          if (e.code !== 'EEXIST') {\n            throw e;\n          }\n        }\n        for (let i = 0, ii = dirContents.length; i < ii; i++) {\n          _copyFile(path.join(from, dirContents[i]), targetDir, {preserveMode: options.preserveMode});\n        }\n      }\n      // Copying a file\n      else {\n        content = fs.readFileSync(from);\n        let mode = fromStat.mode & 0o777;\n        let targetFile = to;\n\n        if (toStat.isDirectory()) {\n          targetFile = path.join(to, filename);\n        }\n\n        let fileExists = fs.existsSync(targetFile);\n        fs.writeFileSync(targetFile, content);\n\n        // If the file didn't already exist, use the original file mode.\n        // Otherwise, only update the mode if preserverMode is true.\n        if(!fileExists || options.preserveMode) {\n          fs.chmodSync(targetFile, mode);\n        }\n      }\n    }\n    // Dest doesn't exist, can't create it\n    else {\n      throw destDoesNotExistErr;\n    }\n  };\n\n  // Remove the given directory\n  let _rmDir = function (dirPath) {\n    let dir = path.normalize(dirPath);\n    let paths = [];\n    paths = fs.readdirSync(dir);\n    paths.forEach(function (p) {\n      let curr = path.join(dir, p);\n      let stat = fs.lstatSync(curr);\n      if (stat.isDirectory()) {\n        _rmDir(curr);\n      }\n      else {\n        try {\n          fs.unlinkSync(curr);\n        } catch(e) {\n          if (e.code === 'EPERM') {\n            fs.chmodSync(curr, parseInt(666, 8));\n            fs.unlinkSync(curr);\n          } else {\n            throw e;\n          }\n        }\n      }\n    });\n    fs.rmdirSync(dir);\n  };\n\n  /**\n    @name file#cpR\n    @public\n    @function\n    @description Copies a directory/file to a destination\n    @param {String} fromPath The source path to copy from\n    @param {String} toPath The destination path to copy to\n    @param {Object} opts Options to use\n      @param {Boolean} [opts.preserveMode] If target file already exists, this\n        determines whether the original file's mode is copied over. The default of\n        false mimics the behavior of the `cp` command line tool. (Default: false)\n  */\n  this.cpR = function (fromPath, toPath, options) {\n    let from = path.normalize(fromPath);\n    let to = path.normalize(toPath);\n    let toStat;\n    let doesNotExistErr;\n    let filename;\n    let opts = options || {};\n\n    if (from == to) {\n      throw new Error('Cannot copy ' + from + ' to itself.');\n    }\n\n    // Handle rename-via-copy\n    try {\n      toStat = fs.statSync(to);\n    }\n    catch(e) {\n      doesNotExistErr = e;\n\n      // Get abs path so it's possible to check parent dir\n      if (!this.isAbsolute(to)) {\n        to = path.join(process.cwd(), to);\n      }\n\n      // Save the file/dir name\n      filename = path.basename(to);\n      // See if a parent dir exists, so there's a place to put the\n      /// renamed file/dir (resets the destination for the copy)\n      to = path.dirname(to);\n      try {\n        toStat = fs.statSync(to);\n      }\n      catch(e) {}\n      if (toStat && toStat.isDirectory()) {\n        // Set the rename opt to pass to the copy func, will be used\n        // as the new file/dir name\n        opts.rename = filename;\n        //console.log('filename ' + filename);\n      }\n      else {\n        throw doesNotExistErr;\n      }\n    }\n\n    _copyFile(from, to, opts);\n  };\n\n  /**\n    @name file#mkdirP\n    @public\n    @function\n    @description Create the given directory(ies) using the given mode permissions\n    @param {String} dir The directory to create\n    @param {Number} mode The mode to give the created directory(ies)(Default: 0755)\n  */\n  this.mkdirP = function (dir, mode) {\n    let dirPath = path.normalize(dir);\n    let paths = dirPath.split(/\\/|\\\\/);\n    let currPath = '';\n    let next;\n\n    if (paths[0] == '' || /^[A-Za-z]+:/.test(paths[0])) {\n      currPath = paths.shift() || '/';\n      currPath = path.join(currPath, paths.shift());\n      //console.log('basedir');\n    }\n    while ((next = paths.shift())) {\n      if (next == '..') {\n        currPath = path.join(currPath, next);\n        continue;\n      }\n      currPath = path.join(currPath, next);\n      try {\n        //console.log('making ' + currPath);\n        fs.mkdirSync(currPath, mode || parseInt(755, 8));\n      }\n      catch(e) {\n        if (e.code != 'EEXIST') {\n          throw e;\n        }\n      }\n    }\n  };\n\n  /**\n    @name file#rmRf\n    @public\n    @function\n    @description Deletes the given directory/file\n    @param {String} p The path to delete, can be a directory or file\n  */\n  this.rmRf = function (p, options) {\n    let stat;\n    try {\n      stat = fs.lstatSync(p);\n      if (stat.isDirectory()) {\n        _rmDir(p);\n      }\n      else {\n        fs.unlinkSync(p);\n      }\n    }\n    catch (e) {}\n  };\n\n  /**\n    @name file#isAbsolute\n    @public\n    @function\n    @return {Boolean/String} If it's absolute the first character is returned otherwise false\n    @description Checks if a given path is absolute or relative\n    @param {String} p Path to check\n  */\n  this.isAbsolute = function (p) {\n    let match = /^[A-Za-z]+:\\\\|^\\//.exec(p);\n    if (match && match.length) {\n      return match[0];\n    }\n    return false;\n  };\n\n  /**\n    @name file#absolutize\n    @public\n    @function\n    @return {String} Returns the absolute path for the given path\n    @description Returns the absolute path for the given path\n    @param {String} p The path to get the absolute path for\n  */\n  this.absolutize = function (p) {\n    if (this.isAbsolute(p)) {\n      return p;\n    }\n    else {\n      return path.join(process.cwd(), p);\n    }\n  };\n\n})();\n\nmodule.exports = fileUtils;\n\n"]},"metadata":{},"sourceType":"module"}