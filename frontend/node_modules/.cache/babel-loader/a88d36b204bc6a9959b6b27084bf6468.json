{"ast":null,"code":"","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["/**\nCreate a type that makes the given keys optional. The remaining keys are kept as is. The sister of the `SetRequired` type.\n\nUse-case: You want to define a single model where the only thing that changes is whether or not some of the keys are optional.\n\n@example\n```\nimport {SetOptional} from 'type-fest';\n\ntype Foo = {\n\ta: number;\n\tb?: string;\n\tc: boolean;\n}\n\ntype SomeOptional = SetOptional<Foo, 'b' | 'c'>;\n// type SomeOptional = {\n// \ta: number;\n// \tb?: string; // Was already optional and still is.\n// \tc?: boolean; // Is now optional.\n// }\n```\n*/\nexport type SetOptional<BaseType, Keys extends keyof BaseType = keyof BaseType> =\n\t// Pick just the keys that are not optional from the base type.\n\tPick<BaseType, Exclude<keyof BaseType, Keys>> &\n\t// Pick the keys that should be optional from the base type and make them optional.\n\tPartial<Pick<BaseType, Keys>> extends\n\t// If `InferredType` extends the previous, then for each key, use the inferred type key.\n\tinfer InferredType\n\t\t? {[KeyType in keyof InferredType]: InferredType[KeyType]}\n\t\t: never;\n"]},"metadata":{},"sourceType":"module"}