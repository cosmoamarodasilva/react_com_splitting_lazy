{"ast":null,"code":"","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["// Helper type. Not useful on its own.\ntype Without<FirstType, SecondType> = {[KeyType in Exclude<keyof FirstType, keyof SecondType>]?: never};\n\n/**\nCreate a type that has mutually exclusive keys.\n\nThis type was inspired by [this comment](https://github.com/Microsoft/TypeScript/issues/14094#issuecomment-373782604).\n\nThis type works with a helper type, called `Without`. `Without<FirstType, SecondType>` produces a type that has only keys from `FirstType` which are not present on `SecondType` and sets the value type for these keys to `never`. This helper type is then used in `MergeExclusive` to remove keys from either `FirstType` or `SecondType`.\n\n@example\n```\nimport {MergeExclusive} from 'type-fest';\n\ninterface ExclusiveVariation1 {\n\texclusive1: boolean;\n}\n\ninterface ExclusiveVariation2 {\n\texclusive2: string;\n}\n\ntype ExclusiveOptions = MergeExclusive<ExclusiveVariation1, ExclusiveVariation2>;\n\nlet exclusiveOptions: ExclusiveOptions;\n\nexclusiveOptions = {exclusive1: true};\n//=> Works\nexclusiveOptions = {exclusive2: 'hi'};\n//=> Works\nexclusiveOptions = {exclusive1: true, exclusive2: 'hi'};\n//=> Error\n```\n*/\nexport type MergeExclusive<FirstType, SecondType> =\n\t(FirstType | SecondType) extends object ?\n\t\t(Without<FirstType, SecondType> & SecondType) | (Without<SecondType, FirstType> & FirstType) :\n\t\tFirstType | SecondType;\n\n"]},"metadata":{},"sourceType":"module"}