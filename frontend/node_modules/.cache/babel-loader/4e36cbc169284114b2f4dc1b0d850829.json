{"ast":null,"code":"let EventEmitter = require('events').EventEmitter;\n\nlet async = require('async');\n\nlet chalk = require('chalk'); // 'rule' module is required at the bottom because circular deps\n// Used for task value, so better not to use\n// null, since value should be unset/uninitialized\n\n\nlet UNDEFINED_VALUE;\nconst ROOT_TASK_NAME = '__rootTask__';\nconst POLLING_INTERVAL = 100; // Parse any positional args attached to the task-name\n\nfunction parsePrereqName(name) {\n  let taskArr = name.split('[');\n  let taskName = taskArr[0];\n  let taskArgs = [];\n\n  if (taskArr[1]) {\n    taskArgs = taskArr[1].replace(/\\]$/, '');\n    taskArgs = taskArgs.split(',');\n  }\n\n  return {\n    name: taskName,\n    args: taskArgs\n  };\n}\n/**\n  @name jake.Task\n  @class\n  @extends EventEmitter\n  @description A Jake Task\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform for this task\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\n\n\nclass Task extends EventEmitter {\n  constructor(name, prereqs, action, options) {\n    // EventEmitter ctor takes no args\n    super();\n\n    if (name.indexOf(':') > -1) {\n      throw new Error('Task name cannot include a colon. It is used internally as namespace delimiter.');\n    }\n\n    let opts = options || {};\n    this._currentPrereqIndex = 0;\n    this._internal = false;\n    this._skipped = false;\n    this.name = name;\n    this.prereqs = prereqs;\n    this.action = action;\n    this.async = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.description = null;\n    this.args = [];\n    this.value = UNDEFINED_VALUE;\n    this.concurrency = 1;\n    this.startTime = null;\n    this.endTime = null;\n    this.directory = null;\n    this.namespace = null; // Support legacy async-flag -- if not explicitly passed or falsy, will\n    // be set to empty-object\n\n    if (typeof opts == 'boolean' && opts === true) {\n      this.async = true;\n    } else {\n      if (opts.async) {\n        this.async = true;\n      }\n\n      if (opts.concurrency) {\n        this.concurrency = opts.concurrency;\n      }\n    } //Do a test on self dependencies for this task\n\n\n    if (Array.isArray(this.prereqs) && this.prereqs.indexOf(this.name) !== -1) {\n      throw new Error(\"Cannot use prereq \" + this.name + \" as a dependency of itself\");\n    }\n  }\n\n  get fullName() {\n    return this._getFullName();\n  }\n\n  _initInvocationChain() {\n    // Legacy global invocation chain\n    jake._invocationChain.push(this); // New root chain\n\n\n    if (!this._invocationChain) {\n      this._invocationChainRoot = true;\n      this._invocationChain = [];\n\n      if (jake.currentRunningTask) {\n        jake.currentRunningTask._waitForChains = jake.currentRunningTask._waitForChains || [];\n\n        jake.currentRunningTask._waitForChains.push(this._invocationChain);\n      }\n    }\n  }\n  /**\n    @name jake.Task#invoke\n    @function\n    @description Runs prerequisites, then this task. If the task has already\n    been run, will not run the task again.\n   */\n\n\n  invoke() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenabled = false;\n    this.runPrereqs();\n  }\n  /**\n    @name jake.Task#execute\n    @function\n    @description Run only this task, without prereqs. If the task has already\n    been run, *will* run the task again.\n   */\n\n\n  execute() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenable();\n    this.reenabled = true;\n    this.run();\n  }\n\n  runPrereqs() {\n    if (this.prereqs && this.prereqs.length) {\n      if (this.concurrency > 1) {\n        async.eachLimit(this.prereqs, this.concurrency, (name, cb) => {\n          let parsed = parsePrereqName(name);\n          let prereq = this.namespace.resolveTask(parsed.name) || jake.attemptRule(name, this.namespace, 0) || jake.createPlaceholderFileTask(name, this.namespace);\n\n          if (!prereq) {\n            throw new Error('Unknown task \"' + name + '\"');\n          } //Test for circular invocation\n\n\n          if (prereq === this) {\n            setImmediate(function () {\n              cb(new Error(\"Cannot use prereq \" + prereq.name + \" as a dependency of itself\"));\n            });\n          }\n\n          if (prereq.taskStatus == Task.runStatuses.DONE) {\n            //prereq already done, return\n            setImmediate(cb);\n          } else {\n            //wait for complete before calling cb\n            prereq.once('_done', () => {\n              prereq.removeAllListeners('_done');\n              setImmediate(cb);\n            }); // Start the prereq if we are the first to encounter it\n\n            if (prereq.taskStatus === Task.runStatuses.UNSTARTED) {\n              prereq.taskStatus = Task.runStatuses.STARTED;\n              prereq.invoke.apply(prereq, parsed.args);\n            }\n          }\n        }, err => {\n          //async callback is called after all prereqs have run.\n          if (err) {\n            throw err;\n          } else {\n            setImmediate(this.run.bind(this));\n          }\n        });\n      } else {\n        setImmediate(this.nextPrereq.bind(this));\n      }\n    } else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  nextPrereq() {\n    let self = this;\n    let index = this._currentPrereqIndex;\n    let name = this.prereqs[index];\n    let prereq;\n    let parsed;\n\n    if (name) {\n      parsed = parsePrereqName(name);\n      prereq = this.namespace.resolveTask(parsed.name) || jake.attemptRule(name, this.namespace, 0) || jake.createPlaceholderFileTask(name, this.namespace);\n\n      if (!prereq) {\n        throw new Error('Unknown task \"' + name + '\"');\n      } // Do when done\n\n\n      if (prereq.taskStatus == Task.runStatuses.DONE) {\n        self.handlePrereqDone(prereq);\n      } else {\n        prereq.once('_done', () => {\n          this.handlePrereqDone(prereq);\n          prereq.removeAllListeners('_done');\n        });\n\n        if (prereq.taskStatus == Task.runStatuses.UNSTARTED) {\n          prereq.taskStatus = Task.runStatuses.STARTED;\n          prereq._invocationChain = this._invocationChain;\n          prereq.invoke.apply(prereq, parsed.args);\n        }\n      }\n    }\n  }\n  /**\n    @name jake.Task#reenable\n    @function\n    @description Reenables a task so that it can be run again.\n   */\n\n\n  reenable(deep) {\n    let prereqs;\n    let prereq;\n    this._skipped = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.value = UNDEFINED_VALUE;\n\n    if (deep && this.prereqs) {\n      prereqs = this.prereqs;\n\n      for (let i = 0, ii = prereqs.length; i < ii; i++) {\n        prereq = jake.Task[prereqs[i]];\n\n        if (prereq) {\n          prereq.reenable(deep);\n        }\n      }\n    }\n  }\n\n  handlePrereqDone(prereq) {\n    this._currentPrereqIndex++;\n\n    if (this._currentPrereqIndex < this.prereqs.length) {\n      setImmediate(this.nextPrereq.bind(this));\n    } else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  isNeeded() {\n    let needed = true;\n\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      needed = false;\n    }\n\n    return needed;\n  }\n\n  run() {\n    let val, previous;\n    let hasAction = typeof this.action == 'function';\n\n    if (!this.isNeeded()) {\n      this.emit('skip');\n      this.emit('_done');\n    } else {\n      if (this._invocationChain.length) {\n        previous = this._invocationChain[this._invocationChain.length - 1]; // If this task is repeating and its previous is equal to this, don't check its status because it was set to UNSTARTED by the reenable() method\n\n        if (!(this.reenabled && previous == this)) {\n          if (previous.taskStatus != Task.runStatuses.DONE) {\n            let now = new Date().getTime();\n\n            if (now - this.startTime > jake._taskTimeout) {\n              return jake.fail(`Timed out waiting for task: ${previous.name} with status of ${previous.taskStatus}`);\n            }\n\n            setTimeout(this.run.bind(this), POLLING_INTERVAL);\n            return;\n          }\n        }\n      }\n\n      if (!(this.reenabled && previous == this)) {\n        this._invocationChain.push(this);\n      }\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Starting '\" + chalk.green(this.fullName) + \"'...\");\n      }\n\n      this.startTime = new Date().getTime();\n      this.emit('start');\n      jake.currentRunningTask = this;\n\n      if (hasAction) {\n        try {\n          if (this.directory) {\n            process.chdir(this.directory);\n          }\n\n          val = this.action.apply(this, this.args);\n\n          if (typeof val == 'object' && typeof val.then == 'function') {\n            this.async = true;\n            val.then(result => {\n              setImmediate(() => {\n                this.complete(result);\n              });\n            }, err => {\n              setImmediate(() => {\n                this.errorOut(err);\n              });\n            });\n          }\n        } catch (err) {\n          this.errorOut(err);\n          return; // Bail out, not complete\n        }\n      }\n\n      if (!(hasAction && this.async)) {\n        setImmediate(() => {\n          this.complete(val);\n        });\n      }\n    }\n  }\n\n  errorOut(err) {\n    this.taskStatus = Task.runStatuses.ERROR;\n    this._invocationChain.chainStatus = Task.runStatuses.ERROR;\n    this.emit('error', err);\n  }\n\n  complete(val) {\n    if (Array.isArray(this._waitForChains)) {\n      let stillWaiting = this._waitForChains.some(chain => {\n        return !(chain.chainStatus == Task.runStatuses.DONE || chain.chainStatus == Task.runStatuses.ERROR);\n      });\n\n      if (stillWaiting) {\n        let now = new Date().getTime();\n        let elapsed = now - this.startTime;\n\n        if (elapsed > jake._taskTimeout) {\n          return jake.fail(`Timed out waiting for task: ${this.name} with status of ${this.taskStatus}. Elapsed: ${elapsed}`);\n        }\n\n        setTimeout(() => {\n          this.complete(val);\n        }, POLLING_INTERVAL);\n        return;\n      }\n    }\n\n    jake._invocationChain.splice(jake._invocationChain.indexOf(this), 1);\n\n    if (this._invocationChainRoot) {\n      this._invocationChain.chainStatus = Task.runStatuses.DONE;\n    }\n\n    this._currentPrereqIndex = 0; // If 'complete' getting called because task has been\n    // run already, value will not be passed -- leave in place\n\n    if (!this._skipped) {\n      this.taskStatus = Task.runStatuses.DONE;\n      this.value = val;\n      this.emit('complete', this.value);\n      this.emit('_done');\n      this.endTime = new Date().getTime();\n      let taskTime = this.endTime - this.startTime;\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Finished '\" + chalk.green(this.fullName) + \"' after \" + chalk.magenta(taskTime + ' ms'));\n      }\n    }\n  }\n\n  _getFullName() {\n    let ns = this.namespace;\n    let path = ns && ns.path || '';\n    path = path && path.split(':') || [];\n\n    if (this.namespace !== jake.defaultNamespace) {\n      path.push(this.namespace.name);\n    }\n\n    path.push(this.name);\n    return path.join(':');\n  }\n\n  static getBaseNamespacePath(fullName) {\n    return fullName.split(':').slice(0, -1).join(':');\n  }\n\n  static getBaseTaskName(fullName) {\n    return fullName.split(':').pop();\n  }\n\n}\n\nTask.runStatuses = {\n  UNSTARTED: 'unstarted',\n  DONE: 'done',\n  STARTED: 'started',\n  ERROR: 'error'\n};\nTask.ROOT_TASK_NAME = ROOT_TASK_NAME;\nexports.Task = Task; // Required here because circular deps\n\nrequire('../rule');","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/task/task.js"],"names":["EventEmitter","require","async","chalk","UNDEFINED_VALUE","ROOT_TASK_NAME","POLLING_INTERVAL","parsePrereqName","name","taskArr","split","taskName","taskArgs","replace","args","Task","constructor","prereqs","action","options","indexOf","Error","opts","_currentPrereqIndex","_internal","_skipped","taskStatus","runStatuses","UNSTARTED","description","value","concurrency","startTime","endTime","directory","namespace","Array","isArray","fullName","_getFullName","_initInvocationChain","jake","_invocationChain","push","_invocationChainRoot","currentRunningTask","_waitForChains","invoke","prototype","slice","call","arguments","reenabled","runPrereqs","execute","reenable","run","length","eachLimit","cb","parsed","prereq","resolveTask","attemptRule","createPlaceholderFileTask","setImmediate","DONE","once","removeAllListeners","STARTED","apply","err","bind","nextPrereq","self","index","handlePrereqDone","deep","i","ii","isNeeded","needed","val","previous","hasAction","emit","now","Date","getTime","_taskTimeout","fail","setTimeout","program","quiet","console","log","green","process","chdir","then","result","complete","errorOut","ERROR","chainStatus","stillWaiting","some","chain","elapsed","splice","taskTime","magenta","ns","path","defaultNamespace","join","getBaseNamespacePath","getBaseTaskName","pop","exports"],"mappings":"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","sourcesContent":["let EventEmitter = require('events').EventEmitter;\nlet async = require('async');\nlet chalk = require('chalk');\n// 'rule' module is required at the bottom because circular deps\n\n// Used for task value, so better not to use\n// null, since value should be unset/uninitialized\nlet UNDEFINED_VALUE;\n\nconst ROOT_TASK_NAME = '__rootTask__';\nconst POLLING_INTERVAL = 100;\n\n// Parse any positional args attached to the task-name\nfunction parsePrereqName(name) {\n  let taskArr = name.split('[');\n  let taskName = taskArr[0];\n  let taskArgs = [];\n  if (taskArr[1]) {\n    taskArgs = taskArr[1].replace(/\\]$/, '');\n    taskArgs = taskArgs.split(',');\n  }\n  return {\n    name: taskName,\n    args: taskArgs\n  };\n}\n\n/**\n  @name jake.Task\n  @class\n  @extends EventEmitter\n  @description A Jake Task\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform for this task\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nclass Task extends EventEmitter {\n\n  constructor(name, prereqs, action, options) {\n    // EventEmitter ctor takes no args\n    super();\n\n    if (name.indexOf(':') > -1) {\n      throw new Error('Task name cannot include a colon. It is used internally as namespace delimiter.');\n    }\n    let opts = options || {};\n\n    this._currentPrereqIndex = 0;\n    this._internal = false;\n    this._skipped = false;\n\n    this.name = name;\n    this.prereqs = prereqs;\n    this.action = action;\n    this.async = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.description = null;\n    this.args = [];\n    this.value = UNDEFINED_VALUE;\n    this.concurrency = 1;\n    this.startTime = null;\n    this.endTime = null;\n    this.directory = null;\n    this.namespace = null;\n\n    // Support legacy async-flag -- if not explicitly passed or falsy, will\n    // be set to empty-object\n    if (typeof opts == 'boolean' && opts === true) {\n      this.async = true;\n    }\n    else {\n      if (opts.async) {\n        this.async = true;\n      }\n      if (opts.concurrency) {\n        this.concurrency = opts.concurrency;\n      }\n    }\n\n    //Do a test on self dependencies for this task\n    if(Array.isArray(this.prereqs) && this.prereqs.indexOf(this.name) !== -1) {\n      throw new Error(\"Cannot use prereq \" + this.name + \" as a dependency of itself\");\n    }\n  }\n\n  get fullName() {\n    return this._getFullName();\n  }\n\n  _initInvocationChain() {\n    // Legacy global invocation chain\n    jake._invocationChain.push(this);\n\n    // New root chain\n    if (!this._invocationChain) {\n      this._invocationChainRoot = true;\n      this._invocationChain = [];\n      if (jake.currentRunningTask) {\n        jake.currentRunningTask._waitForChains = jake.currentRunningTask._waitForChains || [];\n        jake.currentRunningTask._waitForChains.push(this._invocationChain);\n      }\n    }\n  }\n\n  /**\n    @name jake.Task#invoke\n    @function\n    @description Runs prerequisites, then this task. If the task has already\n    been run, will not run the task again.\n   */\n  invoke() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenabled = false\n    this.runPrereqs();\n  }\n\n  /**\n    @name jake.Task#execute\n    @function\n    @description Run only this task, without prereqs. If the task has already\n    been run, *will* run the task again.\n   */\n  execute() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenable();\n    this.reenabled = true\n    this.run();\n  }\n\n  runPrereqs() {\n    if (this.prereqs && this.prereqs.length) {\n\n      if (this.concurrency > 1) {\n        async.eachLimit(this.prereqs, this.concurrency,\n\n          (name, cb) => {\n            let parsed = parsePrereqName(name);\n\n            let prereq = this.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, this.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, this.namespace);\n\n            if (!prereq) {\n              throw new Error('Unknown task \"' + name + '\"');\n            }\n\n            //Test for circular invocation\n            if(prereq === this) {\n              setImmediate(function () {\n                cb(new Error(\"Cannot use prereq \" + prereq.name + \" as a dependency of itself\"));\n              });\n            }\n\n            if (prereq.taskStatus == Task.runStatuses.DONE) {\n            //prereq already done, return\n              setImmediate(cb);\n            }\n            else {\n            //wait for complete before calling cb\n              prereq.once('_done', () => {\n                prereq.removeAllListeners('_done');\n                setImmediate(cb);\n              });\n              // Start the prereq if we are the first to encounter it\n              if (prereq.taskStatus === Task.runStatuses.UNSTARTED) {\n                prereq.taskStatus = Task.runStatuses.STARTED;\n                prereq.invoke.apply(prereq, parsed.args);\n              }\n            }\n          },\n\n          (err) => {\n          //async callback is called after all prereqs have run.\n            if (err) {\n              throw err;\n            }\n            else {\n              setImmediate(this.run.bind(this));\n            }\n          }\n        );\n      }\n      else {\n        setImmediate(this.nextPrereq.bind(this));\n      }\n    }\n    else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  nextPrereq() {\n    let self = this;\n    let index = this._currentPrereqIndex;\n    let name = this.prereqs[index];\n    let prereq;\n    let parsed;\n\n    if (name) {\n\n      parsed = parsePrereqName(name);\n\n      prereq = this.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, this.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, this.namespace);\n\n      if (!prereq) {\n        throw new Error('Unknown task \"' + name + '\"');\n      }\n\n      // Do when done\n      if (prereq.taskStatus == Task.runStatuses.DONE) {\n        self.handlePrereqDone(prereq);\n      }\n      else {\n        prereq.once('_done', () => {\n          this.handlePrereqDone(prereq);\n          prereq.removeAllListeners('_done');\n        });\n        if (prereq.taskStatus == Task.runStatuses.UNSTARTED) {\n          prereq.taskStatus = Task.runStatuses.STARTED;\n          prereq._invocationChain = this._invocationChain;\n          prereq.invoke.apply(prereq, parsed.args);\n        }\n      }\n    }\n  }\n\n  /**\n    @name jake.Task#reenable\n    @function\n    @description Reenables a task so that it can be run again.\n   */\n  reenable(deep) {\n    let prereqs;\n    let prereq;\n    this._skipped = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.value = UNDEFINED_VALUE;\n    if (deep && this.prereqs) {\n      prereqs = this.prereqs;\n      for (let i = 0, ii = prereqs.length; i < ii; i++) {\n        prereq = jake.Task[prereqs[i]];\n        if (prereq) {\n          prereq.reenable(deep);\n        }\n      }\n    }\n  }\n\n  handlePrereqDone(prereq) {\n    this._currentPrereqIndex++;\n    if (this._currentPrereqIndex < this.prereqs.length) {\n      setImmediate(this.nextPrereq.bind(this));\n    }\n    else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  isNeeded() {\n    let needed = true;\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      needed = false;\n    }\n    return needed;\n  }\n\n  run() {\n    let val, previous;\n    let hasAction = typeof this.action == 'function';\n\n    if (!this.isNeeded()) {\n      this.emit('skip');\n      this.emit('_done');\n    }\n    else {\n      if (this._invocationChain.length) {\n        previous = this._invocationChain[this._invocationChain.length - 1];\n        // If this task is repeating and its previous is equal to this, don't check its status because it was set to UNSTARTED by the reenable() method\n        if (!(this.reenabled && previous == this)) {\n          if (previous.taskStatus != Task.runStatuses.DONE) {\n            let now = (new Date()).getTime();\n            if (now - this.startTime > jake._taskTimeout) {\n              return jake.fail(`Timed out waiting for task: ${previous.name} with status of ${previous.taskStatus}`);\n            }\n            setTimeout(this.run.bind(this), POLLING_INTERVAL);\n            return;\n          }\n        }\n      }\n      if (!(this.reenabled && previous == this)) {\n        this._invocationChain.push(this);\n      }\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Starting '\" + chalk.green(this.fullName) + \"'...\");\n      }\n\n      this.startTime = (new Date()).getTime();\n      this.emit('start');\n\n      jake.currentRunningTask = this;\n\n      if (hasAction) {\n        try {\n          if (this.directory) {\n            process.chdir(this.directory);\n          }\n\n          val = this.action.apply(this, this.args);\n\n          if (typeof val == 'object' && typeof val.then == 'function') {\n            this.async = true;\n\n            val.then(\n              (result) => {\n                setImmediate(() => {\n                  this.complete(result);\n                });\n              },\n              (err) => {\n                setImmediate(() => {\n                  this.errorOut(err);\n                });\n              });\n          }\n        }\n        catch (err) {\n          this.errorOut(err);\n          return; // Bail out, not complete\n        }\n      }\n\n      if (!(hasAction && this.async)) {\n        setImmediate(() => {\n          this.complete(val);\n        });\n      }\n    }\n  }\n\n  errorOut(err) {\n    this.taskStatus = Task.runStatuses.ERROR;\n    this._invocationChain.chainStatus = Task.runStatuses.ERROR;\n    this.emit('error', err);\n  }\n\n  complete(val) {\n\n    if (Array.isArray(this._waitForChains)) {\n      let stillWaiting = this._waitForChains.some((chain) => {\n        return !(chain.chainStatus == Task.runStatuses.DONE ||\n              chain.chainStatus == Task.runStatuses.ERROR);\n      });\n      if (stillWaiting) {\n        let now = (new Date()).getTime();\n        let elapsed = now - this.startTime;\n        if (elapsed > jake._taskTimeout) {\n          return jake.fail(`Timed out waiting for task: ${this.name} with status of ${this.taskStatus}. Elapsed: ${elapsed}`);\n        }\n        setTimeout(() => {\n          this.complete(val);\n        }, POLLING_INTERVAL);\n        return;\n      }\n    }\n\n    jake._invocationChain.splice(jake._invocationChain.indexOf(this), 1);\n\n    if (this._invocationChainRoot) {\n      this._invocationChain.chainStatus = Task.runStatuses.DONE;\n    }\n\n    this._currentPrereqIndex = 0;\n\n    // If 'complete' getting called because task has been\n    // run already, value will not be passed -- leave in place\n    if (!this._skipped) {\n      this.taskStatus = Task.runStatuses.DONE;\n      this.value = val;\n\n      this.emit('complete', this.value);\n      this.emit('_done');\n\n      this.endTime = (new Date()).getTime();\n      let taskTime = this.endTime - this.startTime;\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Finished '\" + chalk.green(this.fullName) + \"' after \" + chalk.magenta(taskTime + ' ms'));\n      }\n\n    }\n  }\n\n  _getFullName() {\n    let ns = this.namespace;\n    let path = (ns && ns.path) || '';\n    path = (path && path.split(':')) || [];\n    if (this.namespace !== jake.defaultNamespace) {\n      path.push(this.namespace.name);\n    }\n    path.push(this.name);\n    return path.join(':');\n  }\n\n  static getBaseNamespacePath(fullName) {\n    return fullName.split(':').slice(0, -1).join(':');\n  }\n\n  static getBaseTaskName(fullName) {\n    return fullName.split(':').pop();\n  }\n}\n\nTask.runStatuses = {\n  UNSTARTED: 'unstarted',\n  DONE: 'done',\n  STARTED: 'started',\n  ERROR: 'error'\n};\n\nTask.ROOT_TASK_NAME = ROOT_TASK_NAME;\n\nexports.Task = Task;\n\n// Required here because circular deps\nrequire('../rule');\n\n"]},"metadata":{},"sourceType":"module"}