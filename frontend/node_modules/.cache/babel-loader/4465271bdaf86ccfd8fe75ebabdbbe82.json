{"ast":null,"code":"","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["/**\nCreate a type that makes the given keys required. The remaining keys are kept as is. The sister of the `SetOptional` type.\n\nUse-case: You want to define a single model where the only thing that changes is whether or not some of the keys are required.\n\n@example\n```\nimport {SetRequired} from 'type-fest';\n\ntype Foo = {\n\ta?: number;\n\tb: string;\n\tc?: boolean;\n}\n\ntype SomeRequired = SetRequired<Foo, 'b' | 'c'>;\n// type SomeRequired = {\n// \ta?: number;\n// \tb: string; // Was already required and still is.\n// \tc: boolean; // Is now required.\n// }\n```\n*/\nexport type SetRequired<BaseType, Keys extends keyof BaseType = keyof BaseType> =\n\t// Pick just the keys that are not required from the base type.\n\tPick<BaseType, Exclude<keyof BaseType, Keys>> &\n\t// Pick the keys that should be required from the base type and make them required.\n\tRequired<Pick<BaseType, Keys>> extends\n\t// If `InferredType` extends the previous, then for each key, use the inferred type key.\n\tinfer InferredType\n\t\t? {[KeyType in keyof InferredType]: InferredType[KeyType]}\n\t\t: never;\n"]},"metadata":{},"sourceType":"module"}