{"ast":null,"code":"","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["// TODO: Remove this when we target TypeScript >=3.5.\n// eslint-disable-next-line @typescript-eslint/generic-type-naming\ntype _Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n\n/**\nCreate a type that requires exactly one of the given keys and disallows more. The remaining keys are kept as is.\n\nUse-cases:\n- Creating interfaces for components that only need one of the keys to display properly.\n- Declaring generic keys in a single place for a single use-case that gets narrowed down via `RequireExactlyOne`.\n\nThe caveat with `RequireExactlyOne` is that TypeScript doesn't always know at compile time every key that will exist at runtime. Therefore `RequireExactlyOne` can't do anything to prevent extra keys it doesn't know about.\n\n@example\n```\nimport {RequireExactlyOne} from 'type-fest';\n\ntype Responder = {\n\ttext: () => string;\n\tjson: () => string;\n\tsecure: boolean;\n};\n\nconst responder: RequireExactlyOne<Responder, 'text' | 'json'> = {\n\t// Adding a `text` key here would cause a compile error.\n\n\tjson: () => '{\"message\": \"ok\"}',\n\tsecure: true\n};\n```\n*/\nexport type RequireExactlyOne<ObjectType, KeysType extends keyof ObjectType = keyof ObjectType> =\n\t{[Key in KeysType]: (\n\t\tRequired<Pick<ObjectType, Key>> &\n\t\tPartial<Record<Exclude<KeysType, Key>, never>>\n\t)}[KeysType] & _Omit<ObjectType, KeysType>;\n"]},"metadata":{},"sourceType":"module"}