{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet {\n  uuid\n} = require('./utils');\n\nlet api = new function () {\n  /**\n    @name task\n    @static\n    @function\n    @description Creates a Jake Task\n    `\n    @param {String} name The name of the Task\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n     @example\n    desc('This is the default task.');\n    task('default', function (params) {\n      console.log('This is the default task.');\n    });\n     desc('This task has prerequisites.');\n    task('hasPrereqs', ['foo', 'bar', 'baz'], function (params) {\n      console.log('Ran some prereqs first.');\n    });\n     desc('This is an asynchronous task.');\n    task('asyncTask', function () {\n      setTimeout(complete, 1000);\n    }, {async: true});\n   */\n  this.task = function (name, prereqs, action, opts) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('task');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n  /**\n    @name rule\n    @static\n    @function\n    @description Creates a Jake Suffix Rule\n    `\n    @param {String} pattern The suffix name of the objective\n    @param {String} source The suffix name of the objective\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n    @example\n    desc('This is a rule, which does not support namespace or pattern.');\n    rule('.o', '.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n     desc('This rule has prerequisites.');\n    rule('.o', '.c', ['util.h'], {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n     desc('This is a rule with patterns.');\n    rule('%.o', '%.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n     desc('This is another rule with patterns.');\n    rule('obj/%.o', 'src/%.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n     desc('This is an example with chain rules.');\n    rule('%.pdf', '%.dvi', {async: true}, function () {\n      let cmd = util.format('dvipdfm %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n     rule('%.dvi', '%.tex', {async: true}, function () {\n      let cmd = util.format('latex %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n     desc('This rule has a namespace.');\n    task('default', ['debug:obj/main.o]);\n     namespace('debug', {async: true}, function() {\n      rule('obj/%.o', 'src/%.c', function () {\n        // ...\n      });\n    }\n   */\n\n\n  this.rule = function () {\n    let args = Array.prototype.slice.call(arguments);\n    let arg;\n    let pattern = args.shift();\n    let source = args.shift();\n    let prereqs = [];\n\n    let action = function () {};\n\n    let opts = {};\n    let key = pattern.toString(); // May be a RegExp\n\n    while (arg = args.shift()) {\n      if (typeof arg == 'function') {\n        action = arg;\n      } else if (Array.isArray(arg)) {\n        prereqs = arg;\n      } else {\n        opts = arg;\n      }\n    }\n\n    jake.currentNamespace.rules[key] = new jake.Rule({\n      pattern: pattern,\n      source: source,\n      prereqs: prereqs,\n      action: action,\n      opts: opts,\n      desc: jake.currentTaskDescription,\n      ns: jake.currentNamespace\n    });\n    jake.currentTaskDescription = null;\n  };\n  /**\n    @name directory\n    @static\n    @function\n    @description Creates a Jake DirectoryTask. Can be used as a prerequisite\n    for FileTasks, or for simply ensuring a directory exists for use with a\n    Task's action.\n    `\n    @param {String} name The name of the DiretoryTask\n     @example\n     // Creates the package directory for distribution\n    directory('pkg');\n   */\n\n\n  this.directory = function (name) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('directory');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n  /**\n    @name file\n    @static\n    @function\n    @description Creates a Jake FileTask.\n    `\n    @param {String} name The name of the FileTask\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to create this file, if it doesn't\n    exist already.\n    @param {Object} [opts]\n      @param {Array} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n    */\n\n\n  this.file = function (name, prereqs, action, opts) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('file');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n  /**\n    @name desc\n    @static\n    @function\n    @description Creates a description for a Jake Task (or FileTask,\n    DirectoryTask). When invoked, the description that iscreated will\n    be associated with whatever Task is created next.\n    `\n    @param {String} description The description for the Task\n   */\n\n\n  this.desc = function (description) {\n    jake.currentTaskDescription = description;\n  };\n  /**\n    @name namespace\n    @static\n    @function\n    @description Creates a namespace which allows logical grouping\n    of tasks, and prevents name-collisions with task-names. Namespaces\n    can be nested inside of other namespaces.\n    `\n    @param {String} name The name of the namespace\n    @param {Function} scope The enclosing scope for the namespaced tasks\n     @example\n    namespace('doc', function () {\n      task('generate', ['doc:clobber'], function () {\n        // Generate some docs\n      });\n       task('clobber', function () {\n        // Clobber the doc directory first\n      });\n    });\n   */\n\n\n  this.namespace = function (name, closure) {\n    let curr = jake.currentNamespace;\n    let ns = curr.childNamespaces[name] || new jake.Namespace(name, curr);\n\n    let fn = closure || function () {};\n\n    curr.childNamespaces[name] = ns;\n    jake.currentNamespace = ns;\n    fn();\n    jake.currentNamespace = curr;\n    jake.currentTaskDescription = null;\n    return ns;\n  };\n  /**\n    @name complete\n    @static\n    @function\n    @description Completes an asynchronous task, allowing Jake's\n    execution to proceed to the next task. Calling complete globally or without\n    arguments completes the last task on the invocationChain. If you use parallel\n    execution of prereqs this will probably complete a wrong task. You should call this\n    function with this task as the first argument, before the optional return value.\n    Alternatively you can call task.complete()\n    `\n    @example\n    task('generate', ['doc:clobber'], function () {\n      exec('./generate_docs.sh', function (err, stdout, stderr) {\n        if (err || stderr) {\n          fail(err || stderr);\n        }\n        else {\n          console.log(stdout);\n          complete();\n        }\n      });\n    }, {async: true});\n   */\n\n\n  this.complete = function (task, val) {\n    //this should detect if the first arg is a task, but I guess it should be more thorough\n    if (task && task._currentPrereqIndex >= 0) {\n      task.complete(val);\n    } else {\n      val = task;\n\n      if (jake._invocationChain.length > 0) {\n        jake._invocationChain[jake._invocationChain.length - 1].complete(val);\n      }\n    }\n  };\n  /**\n    @name fail\n    @static\n    @function\n    @description Causes Jake execution to abort with an error.\n    Allows passing an optional error code, which will be used to\n    set the exit-code of exiting process.\n    `\n    @param {Error|String} err The error to thow when aborting execution.\n    If this argument is an Error object, it will simply be thrown. If\n    a String, it will be used as the error-message. (If it is a multi-line\n    String, the first line will be used as the Error message, and the\n    remaining lines will be used as the error-stack.)\n     @example\n    task('createTests, function () {\n      if (!fs.existsSync('./tests')) {\n        fail('Test directory does not exist.');\n      }\n      else {\n        // Do some testing stuff ...\n      }\n    });\n   */\n\n\n  this.fail = function (err, code) {\n    let msg;\n    let errObj;\n\n    if (code) {\n      jake.errorCode = code;\n    }\n\n    if (err) {\n      if (typeof err == 'string') {\n        // Use the initial or only line of the error as the error-message\n        // If there was a multi-line error, use the rest as the stack\n        msg = err.split('\\n');\n        errObj = new Error(msg.shift());\n\n        if (msg.length) {\n          errObj.stack = msg.join('\\n');\n        }\n\n        throw errObj;\n      } else if (err instanceof Error) {\n        throw err;\n      } else {\n        throw new Error(err.toString());\n      }\n    } else {\n      throw new Error();\n    }\n  };\n\n  this.packageTask = function (name, version, prereqs, definition) {\n    return new jake.PackageTask(name, version, prereqs, definition);\n  };\n\n  this.publishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  }; // Backward-compat\n\n\n  this.npmPublishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  };\n\n  this.testTask = function () {\n    let ctor = function () {};\n\n    let t;\n    ctor.prototype = jake.TestTask.prototype;\n    t = new ctor();\n    jake.TestTask.apply(t, arguments);\n    return t;\n  };\n\n  this.setTaskTimeout = function (t) {\n    this._taskTimeout = t;\n  };\n\n  this.setSeriesAutoPrefix = function (prefix) {\n    this._seriesAutoPrefix = prefix;\n  };\n\n  this.series = function (...args) {\n    let prereqs = args.map(arg => {\n      let name = (this._seriesAutoPrefix || '') + arg.name;\n      jake.task(name, arg);\n      return name;\n    });\n    let seriesName = uuid();\n    let seriesTask = jake.task(seriesName, prereqs);\n    seriesTask._internal = true;\n\n    let res = function () {\n      return new Promise(resolve => {\n        seriesTask.invoke();\n        seriesTask.on('complete', val => {\n          resolve(val);\n        });\n      });\n    };\n\n    Object.defineProperty(res, 'name', {\n      value: uuid(),\n      writable: false\n    });\n    return res;\n  };\n}();\nmodule.exports = api;","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/api.js"],"names":["uuid","require","api","task","name","prereqs","action","opts","args","Array","prototype","slice","call","arguments","createdTask","unshift","jake","createTask","apply","global","currentTaskDescription","rule","arg","pattern","shift","source","key","toString","isArray","currentNamespace","rules","Rule","desc","ns","directory","file","description","namespace","closure","curr","childNamespaces","Namespace","fn","complete","val","_currentPrereqIndex","_invocationChain","length","fail","err","code","msg","errObj","errorCode","split","Error","stack","join","packageTask","version","definition","PackageTask","publishTask","PublishTask","npmPublishTask","testTask","ctor","t","TestTask","setTaskTimeout","_taskTimeout","setSeriesAutoPrefix","prefix","_seriesAutoPrefix","series","map","seriesName","seriesTask","_internal","res","Promise","resolve","invoke","on","Object","defineProperty","value","writable","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AAAEA,EAAAA;AAAF,IAAWC,OAAO,CAAC,SAAD,CAAtB;;AAEA,IAAIC,GAAG,GAAG,IAAK,YAAY;AACzB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIE,OAAKC,IAAL,GAAY,UAAUC,IAAV,EAAgBC,OAAhB,EAAyBC,MAAzB,EAAiCC,IAAjC,EAAuC;AACjD,QAAIC,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAX;AACA,QAAIC,WAAJ;AACAN,IAAAA,IAAI,CAACO,OAAL,CAAa,MAAb;AACAD,IAAAA,WAAW,GAAGE,IAAI,CAACC,UAAL,CAAgBC,KAAhB,CAAsBC,MAAtB,EAA8BX,IAA9B,CAAd;AACAQ,IAAAA,IAAI,CAACI,sBAAL,GAA8B,IAA9B;AACA,WAAON,WAAP;AACD,GAPD;AASA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAQE,OAAKO,IAAL,GAAY,YAAY;AACtB,QAAIb,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAX;AACA,QAAIS,GAAJ;AACA,QAAIC,OAAO,GAAGf,IAAI,CAACgB,KAAL,EAAd;AACA,QAAIC,MAAM,GAAGjB,IAAI,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","sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet { uuid } = require('./utils');\n\nlet api = new (function () {\n  /**\n    @name task\n    @static\n    @function\n    @description Creates a Jake Task\n    `\n    @param {String} name The name of the Task\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n\n    @example\n    desc('This is the default task.');\n    task('default', function (params) {\n      console.log('This is the default task.');\n    });\n\n    desc('This task has prerequisites.');\n    task('hasPrereqs', ['foo', 'bar', 'baz'], function (params) {\n      console.log('Ran some prereqs first.');\n    });\n\n    desc('This is an asynchronous task.');\n    task('asyncTask', function () {\n      setTimeout(complete, 1000);\n    }, {async: true});\n   */\n  this.task = function (name, prereqs, action, opts) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('task');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name rule\n    @static\n    @function\n    @description Creates a Jake Suffix Rule\n    `\n    @param {String} pattern The suffix name of the objective\n    @param {String} source The suffix name of the objective\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to perform for this task\n    @param {Object} [opts]\n      @param {Boolean} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n    @example\n    desc('This is a rule, which does not support namespace or pattern.');\n    rule('.o', '.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This rule has prerequisites.');\n    rule('.o', '.c', ['util.h'], {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is a rule with patterns.');\n    rule('%.o', '%.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is another rule with patterns.');\n    rule('obj/%.o', 'src/%.c', {async: true}, function () {\n      let cmd = util.format('gcc -o %s %s', this.name, this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This is an example with chain rules.');\n    rule('%.pdf', '%.dvi', {async: true}, function () {\n      let cmd = util.format('dvipdfm %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    rule('%.dvi', '%.tex', {async: true}, function () {\n      let cmd = util.format('latex %s',this.source);\n      jake.exec([cmd], function () {\n        complete();\n      }, {printStdout: true});\n    });\n\n    desc('This rule has a namespace.');\n    task('default', ['debug:obj/main.o]);\n\n    namespace('debug', {async: true}, function() {\n      rule('obj/%.o', 'src/%.c', function () {\n        // ...\n      });\n    }\n   */\n  this.rule = function () {\n    let args = Array.prototype.slice.call(arguments);\n    let arg;\n    let pattern = args.shift();\n    let source = args.shift();\n    let prereqs = [];\n    let action = function () {};\n    let opts = {};\n    let key = pattern.toString(); // May be a RegExp\n\n    while ((arg = args.shift())) {\n      if (typeof arg == 'function') {\n        action = arg;\n      }\n      else if (Array.isArray(arg)) {\n        prereqs = arg;\n      }\n      else {\n        opts = arg;\n      }\n    }\n\n    jake.currentNamespace.rules[key] = new jake.Rule({\n      pattern: pattern,\n      source: source,\n      prereqs: prereqs,\n      action: action,\n      opts: opts,\n      desc: jake.currentTaskDescription,\n      ns: jake.currentNamespace\n    });\n    jake.currentTaskDescription = null;\n  };\n\n  /**\n    @name directory\n    @static\n    @function\n    @description Creates a Jake DirectoryTask. Can be used as a prerequisite\n    for FileTasks, or for simply ensuring a directory exists for use with a\n    Task's action.\n    `\n    @param {String} name The name of the DiretoryTask\n\n    @example\n\n    // Creates the package directory for distribution\n    directory('pkg');\n   */\n  this.directory = function (name) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('directory');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name file\n    @static\n    @function\n    @description Creates a Jake FileTask.\n    `\n    @param {String} name The name of the FileTask\n    @param {Array} [prereqs] Prerequisites to be run before this task\n    @param {Function} [action] The action to create this file, if it doesn't\n    exist already.\n    @param {Object} [opts]\n      @param {Array} [opts.asyc=false] Perform this task asynchronously.\n      If you flag a task with this option, you must call the global\n      `complete` method inside the task's action, for execution to proceed\n      to the next task.\n\n   */\n  this.file = function (name, prereqs, action, opts) {\n    let args = Array.prototype.slice.call(arguments);\n    let createdTask;\n    args.unshift('file');\n    createdTask = jake.createTask.apply(global, args);\n    jake.currentTaskDescription = null;\n    return createdTask;\n  };\n\n  /**\n    @name desc\n    @static\n    @function\n    @description Creates a description for a Jake Task (or FileTask,\n    DirectoryTask). When invoked, the description that iscreated will\n    be associated with whatever Task is created next.\n    `\n    @param {String} description The description for the Task\n   */\n  this.desc = function (description) {\n    jake.currentTaskDescription = description;\n  };\n\n  /**\n    @name namespace\n    @static\n    @function\n    @description Creates a namespace which allows logical grouping\n    of tasks, and prevents name-collisions with task-names. Namespaces\n    can be nested inside of other namespaces.\n    `\n    @param {String} name The name of the namespace\n    @param {Function} scope The enclosing scope for the namespaced tasks\n\n    @example\n    namespace('doc', function () {\n      task('generate', ['doc:clobber'], function () {\n        // Generate some docs\n      });\n\n      task('clobber', function () {\n        // Clobber the doc directory first\n      });\n    });\n   */\n  this.namespace = function (name, closure) {\n    let curr = jake.currentNamespace;\n    let ns = curr.childNamespaces[name] || new jake.Namespace(name, curr);\n    let fn = closure || function () {};\n    curr.childNamespaces[name] = ns;\n    jake.currentNamespace = ns;\n    fn();\n    jake.currentNamespace = curr;\n    jake.currentTaskDescription = null;\n    return ns;\n  };\n\n  /**\n    @name complete\n    @static\n    @function\n    @description Completes an asynchronous task, allowing Jake's\n    execution to proceed to the next task. Calling complete globally or without\n    arguments completes the last task on the invocationChain. If you use parallel\n    execution of prereqs this will probably complete a wrong task. You should call this\n    function with this task as the first argument, before the optional return value.\n    Alternatively you can call task.complete()\n    `\n    @example\n    task('generate', ['doc:clobber'], function () {\n      exec('./generate_docs.sh', function (err, stdout, stderr) {\n        if (err || stderr) {\n          fail(err || stderr);\n        }\n        else {\n          console.log(stdout);\n          complete();\n        }\n      });\n    }, {async: true});\n   */\n  this.complete = function (task, val) {\n    //this should detect if the first arg is a task, but I guess it should be more thorough\n    if(task && task. _currentPrereqIndex >=0 ) {\n      task.complete(val);\n    }\n    else {\n      val = task;\n      if(jake._invocationChain.length > 0) {\n        jake._invocationChain[jake._invocationChain.length-1].complete(val);\n      }\n    }\n  };\n\n  /**\n    @name fail\n    @static\n    @function\n    @description Causes Jake execution to abort with an error.\n    Allows passing an optional error code, which will be used to\n    set the exit-code of exiting process.\n    `\n    @param {Error|String} err The error to thow when aborting execution.\n    If this argument is an Error object, it will simply be thrown. If\n    a String, it will be used as the error-message. (If it is a multi-line\n    String, the first line will be used as the Error message, and the\n    remaining lines will be used as the error-stack.)\n\n    @example\n    task('createTests, function () {\n      if (!fs.existsSync('./tests')) {\n        fail('Test directory does not exist.');\n      }\n      else {\n        // Do some testing stuff ...\n      }\n    });\n   */\n  this.fail = function (err, code) {\n    let msg;\n    let errObj;\n    if (code) {\n      jake.errorCode = code;\n    }\n    if (err) {\n      if (typeof err == 'string') {\n        // Use the initial or only line of the error as the error-message\n        // If there was a multi-line error, use the rest as the stack\n        msg = err.split('\\n');\n        errObj = new Error(msg.shift());\n        if (msg.length) {\n          errObj.stack = msg.join('\\n');\n        }\n        throw errObj;\n      }\n      else if (err instanceof Error) {\n        throw err;\n      }\n      else {\n        throw new Error(err.toString());\n      }\n    }\n    else {\n      throw new Error();\n    }\n  };\n\n  this.packageTask = function (name, version, prereqs, definition) {\n    return new jake.PackageTask(name, version, prereqs, definition);\n  };\n\n  this.publishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  };\n\n  // Backward-compat\n  this.npmPublishTask = function (name, prereqs, opts, definition) {\n    return new jake.PublishTask(name, prereqs, opts, definition);\n  };\n\n  this.testTask = function () {\n    let ctor = function () {};\n    let t;\n    ctor.prototype = jake.TestTask.prototype;\n    t = new ctor();\n    jake.TestTask.apply(t, arguments);\n    return t;\n  };\n\n  this.setTaskTimeout = function (t) {\n    this._taskTimeout = t;\n  };\n\n  this.setSeriesAutoPrefix = function (prefix) {\n    this._seriesAutoPrefix = prefix;\n  };\n\n  this.series = function (...args) {\n    let prereqs = args.map((arg) => {\n      let name = (this._seriesAutoPrefix || '') + arg.name;\n      jake.task(name, arg);\n      return name;\n    });\n    let seriesName = uuid();\n    let seriesTask = jake.task(seriesName, prereqs);\n    seriesTask._internal = true;\n    let res = function () {\n      return new Promise((resolve) => {\n        seriesTask.invoke();\n        seriesTask.on('complete', (val) => {\n          resolve(val);\n        });\n      });\n    };\n    Object.defineProperty(res, 'name', {value: uuid(),\n      writable: false});\n    return res;\n  };\n\n})();\n\nmodule.exports = api;\n"]},"metadata":{},"sourceType":"module"}