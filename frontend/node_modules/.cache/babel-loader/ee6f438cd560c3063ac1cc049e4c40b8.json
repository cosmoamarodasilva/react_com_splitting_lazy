{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nif (!global.jake) {\n  let EventEmitter = require('events').EventEmitter; // And so it begins\n\n\n  global.jake = new EventEmitter();\n\n  let fs = require('fs');\n\n  let chalk = require('chalk');\n\n  let taskNs = require('./task');\n\n  let Task = taskNs.Task;\n  let FileTask = taskNs.FileTask;\n  let DirectoryTask = taskNs.DirectoryTask;\n\n  let Rule = require('./rule').Rule;\n\n  let Namespace = require('./namespace').Namespace;\n\n  let RootNamespace = require('./namespace').RootNamespace;\n\n  let api = require('./api');\n\n  let utils = require('./utils');\n\n  let Program = require('./program').Program;\n\n  let loader = require('./loader')();\n\n  let pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json').toString());\n  const MAX_RULE_RECURSION_LEVEL = 16; // Globalize jake and top-level API methods (e.g., `task`, `desc`)\n\n  Object.assign(global, api); // Copy utils onto base jake\n\n  jake.logger = utils.logger;\n  jake.exec = utils.exec; // File utils should be aliased directly on base jake as well\n\n  Object.assign(jake, utils.file); // Also add top-level API methods to exported object for those who don't want to\n  // use the globals (`file` here will overwrite the 'file' utils namespace)\n\n  Object.assign(jake, api);\n  Object.assign(jake, new function () {\n    this._invocationChain = [];\n    this._taskTimeout = 30000; // Public properties\n    // =================\n\n    this.version = pkg.version; // Used when Jake exits with a specific error-code\n\n    this.errorCode = null; // Loads Jakefiles/jakelibdirs\n\n    this.loader = loader; // The root of all ... namespaces\n\n    this.rootNamespace = new RootNamespace(); // Non-namespaced tasks are placed into the default\n\n    this.defaultNamespace = this.rootNamespace; // Start in the default\n\n    this.currentNamespace = this.defaultNamespace; // Saves the description created by a 'desc' call that prefaces a\n    // 'task' call that defines a task.\n\n    this.currentTaskDescription = null;\n    this.program = new Program();\n    this.FileList = require('filelist').FileList;\n    this.PackageTask = require('./package_task').PackageTask;\n    this.PublishTask = require('./publish_task').PublishTask;\n    this.TestTask = require('./test_task').TestTask;\n    this.Task = Task;\n    this.FileTask = FileTask;\n    this.DirectoryTask = DirectoryTask;\n    this.Namespace = Namespace;\n    this.Rule = Rule;\n\n    this.parseAllTasks = function () {\n      let _parseNs = function (ns) {\n        let nsTasks = ns.tasks;\n        let nsNamespaces = ns.childNamespaces;\n\n        for (let q in nsTasks) {\n          let nsTask = nsTasks[q];\n          jake.Task[nsTask.fullName] = nsTask;\n        }\n\n        for (let p in nsNamespaces) {\n          let nsNamespace = nsNamespaces[p];\n\n          _parseNs(nsNamespace);\n        }\n      };\n\n      _parseNs(jake.defaultNamespace);\n    };\n    /**\n     * Displays the list of descriptions avaliable for tasks defined in\n     * a Jakefile\n     */\n\n\n    this.showAllTaskDescriptions = function (f) {\n      let p;\n      let maxTaskNameLength = 0;\n      let task;\n      let padding;\n      let name;\n      let descr;\n      let filter = typeof f == 'string' ? f : null;\n\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n\n        task = jake.Task[p]; // Record the length of the longest task name -- used for\n        // pretty alignment of the task descriptions\n\n        if (task.description) {\n          maxTaskNameLength = p.length > maxTaskNameLength ? p.length : maxTaskNameLength;\n        }\n      } // Print out each entry with descriptions neatly aligned\n\n\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n\n        task = jake.Task[p]; //name = '\\033[32m' + p + '\\033[39m ';\n\n        name = chalk.green(p);\n        descr = task.description;\n\n        if (descr) {\n          descr = chalk.gray('# ' + descr); // Create padding-string with calculated length\n\n          padding = new Array(maxTaskNameLength - p.length + 2).join(' ');\n          console.log('jake ' + name + padding + descr);\n        }\n      }\n    };\n\n    this.createTask = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let arg;\n      let obj;\n      let task;\n      let type;\n      let name;\n      let action;\n      let opts = {};\n      let prereqs = [];\n      type = args.shift(); // name, [deps], [action]\n      // Name (string) + deps (array) format\n\n      if (typeof args[0] == 'string') {\n        name = args.shift();\n\n        if (Array.isArray(args[0])) {\n          prereqs = args.shift();\n        }\n      } // name:deps, [action]\n      // Legacy object-literal syntax, e.g.: {'name': ['depA', 'depB']}\n      else {\n          obj = args.shift();\n\n          for (let p in obj) {\n            prereqs = prereqs.concat(obj[p]);\n            name = p;\n          }\n        } // Optional opts/callback or callback/opts\n\n\n      while (arg = args.shift()) {\n        if (typeof arg == 'function') {\n          action = arg;\n        } else {\n          opts = Object.assign(Object.create(null), arg);\n        }\n      }\n\n      task = jake.currentNamespace.resolveTask(name);\n\n      if (task && !action) {\n        // Task already exists and no action, just update prereqs, and return it.\n        task.prereqs = task.prereqs.concat(prereqs);\n        return task;\n      }\n\n      switch (type) {\n        case 'directory':\n          action = function () {\n            jake.mkdirP(name);\n          };\n\n          task = new DirectoryTask(name, prereqs, action, opts);\n          break;\n\n        case 'file':\n          task = new FileTask(name, prereqs, action, opts);\n          break;\n\n        default:\n          task = new Task(name, prereqs, action, opts);\n      }\n\n      jake.currentNamespace.addTask(task);\n\n      if (jake.currentTaskDescription) {\n        task.description = jake.currentTaskDescription;\n        jake.currentTaskDescription = null;\n      } // FIXME: Should only need to add a new entry for the current\n      // task-definition, not reparse the entire structure\n\n\n      jake.parseAllTasks();\n      return task;\n    };\n\n    this.attemptRule = function (name, ns, level) {\n      let prereqRule;\n      let prereq;\n\n      if (level > MAX_RULE_RECURSION_LEVEL) {\n        return null;\n      } // Check Rule\n\n\n      prereqRule = ns.matchRule(name);\n\n      if (prereqRule) {\n        prereq = prereqRule.createTask(name, level);\n      }\n\n      return prereq || null;\n    };\n\n    this.createPlaceholderFileTask = function (name, namespace) {\n      let parsed = name.split(':');\n      let filePath = parsed.pop(); // Strip any namespace\n\n      let task;\n      task = namespace.resolveTask(name); // If there's not already an existing dummy FileTask for it,\n      // create one\n\n      if (!task) {\n        // Create a dummy FileTask only if file actually exists\n        if (fs.existsSync(filePath)) {\n          task = new jake.FileTask(filePath);\n          task.dummy = true;\n          let ns;\n\n          if (parsed.length) {\n            ns = namespace.resolveNamespace(parsed.join(':'));\n          } else {\n            ns = namespace;\n          }\n\n          if (!namespace) {\n            throw new Error('Invalid namespace, cannot add FileTask');\n          }\n\n          ns.addTask(task); // Put this dummy Task in the global Tasks list so\n          // modTime will be eval'd correctly\n\n          jake.Task[`${ns.path}:${filePath}`] = task;\n        }\n      }\n\n      return task || null;\n    };\n\n    this.run = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let program = this.program;\n      let loader = this.loader;\n      let preempt;\n      let opts;\n      program.parseArgs(args);\n      program.init();\n      preempt = program.firstPreemptiveOption();\n\n      if (preempt) {\n        preempt();\n      } else {\n        opts = program.opts; // jakefile flag set but no jakefile yet\n\n        if (opts.autocomplete && opts.jakefile === true) {\n          process.stdout.write('no-complete');\n          return;\n        } // Load Jakefile and jakelibdir files\n\n\n        let jakefileLoaded = loader.loadFile(opts.jakefile);\n        let jakelibdirLoaded = loader.loadDirectory(opts.jakelibdir);\n\n        if (!jakefileLoaded && !jakelibdirLoaded && !opts.autocomplete) {\n          fail('No Jakefile. Specify a valid path with -f/--jakefile, ' + 'or place one in the current directory.');\n        }\n\n        program.run();\n      }\n    };\n  }());\n}\n\nmodule.exports = jake;","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/jake.js"],"names":["global","jake","EventEmitter","require","fs","chalk","taskNs","Task","FileTask","DirectoryTask","Rule","Namespace","RootNamespace","api","utils","Program","loader","pkg","JSON","parse","readFileSync","__dirname","toString","MAX_RULE_RECURSION_LEVEL","Object","assign","logger","exec","file","_invocationChain","_taskTimeout","version","errorCode","rootNamespace","defaultNamespace","currentNamespace","currentTaskDescription","program","FileList","PackageTask","PublishTask","TestTask","parseAllTasks","_parseNs","ns","nsTasks","tasks","nsNamespaces","childNamespaces","q","nsTask","fullName","p","nsNamespace","showAllTaskDescriptions","f","maxTaskNameLength","task","padding","name","descr","filter","prototype","hasOwnProperty","call","indexOf","description","length","green","gray","Array","join","console","log","createTask","args","slice","arguments","arg","obj","type","action","opts","prereqs","shift","isArray","concat","create","resolveTask","mkdirP","addTask","attemptRule","level","prereqRule","prereq","matchRule","createPlaceholderFileTask","namespace","parsed","split","filePath","pop","existsSync","dummy","resolveNamespace","Error","path","run","preempt","parseArgs","init","firstPreemptiveOption","autocomplete","jakefile","process","stdout","write","jakefileLoaded","loadFile","jakelibdirLoaded","loadDirectory","jakelibdir","fail","module","exports"],"mappings":"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","sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nif (!global.jake) {\n\n  let EventEmitter = require('events').EventEmitter;\n  // And so it begins\n  global.jake = new EventEmitter();\n\n  let fs = require('fs');\n  let chalk = require('chalk');\n  let taskNs = require('./task');\n  let Task = taskNs.Task;\n  let FileTask = taskNs.FileTask;\n  let DirectoryTask = taskNs.DirectoryTask;\n  let Rule = require('./rule').Rule;\n  let Namespace = require('./namespace').Namespace;\n  let RootNamespace = require('./namespace').RootNamespace;\n  let api = require('./api');\n  let utils = require('./utils');\n  let Program = require('./program').Program;\n  let loader = require('./loader')();\n  let pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json').toString());\n\n  const MAX_RULE_RECURSION_LEVEL = 16;\n\n  // Globalize jake and top-level API methods (e.g., `task`, `desc`)\n  Object.assign(global, api);\n\n  // Copy utils onto base jake\n  jake.logger = utils.logger;\n  jake.exec = utils.exec;\n\n  // File utils should be aliased directly on base jake as well\n  Object.assign(jake, utils.file);\n\n  // Also add top-level API methods to exported object for those who don't want to\n  // use the globals (`file` here will overwrite the 'file' utils namespace)\n  Object.assign(jake, api);\n\n  Object.assign(jake, new (function () {\n\n    this._invocationChain = [];\n    this._taskTimeout = 30000;\n\n    // Public properties\n    // =================\n    this.version = pkg.version;\n    // Used when Jake exits with a specific error-code\n    this.errorCode = null;\n    // Loads Jakefiles/jakelibdirs\n    this.loader = loader;\n    // The root of all ... namespaces\n    this.rootNamespace = new RootNamespace();\n    // Non-namespaced tasks are placed into the default\n    this.defaultNamespace = this.rootNamespace;\n    // Start in the default\n    this.currentNamespace = this.defaultNamespace;\n    // Saves the description created by a 'desc' call that prefaces a\n    // 'task' call that defines a task.\n    this.currentTaskDescription = null;\n    this.program = new Program();\n    this.FileList = require('filelist').FileList;\n    this.PackageTask = require('./package_task').PackageTask;\n    this.PublishTask = require('./publish_task').PublishTask;\n    this.TestTask = require('./test_task').TestTask;\n    this.Task = Task;\n    this.FileTask = FileTask;\n    this.DirectoryTask = DirectoryTask;\n    this.Namespace = Namespace;\n    this.Rule = Rule;\n\n    this.parseAllTasks = function () {\n      let _parseNs = function (ns) {\n        let nsTasks = ns.tasks;\n        let nsNamespaces = ns.childNamespaces;\n        for (let q in nsTasks) {\n          let nsTask = nsTasks[q];\n          jake.Task[nsTask.fullName] = nsTask;\n        }\n        for (let p in nsNamespaces) {\n          let nsNamespace = nsNamespaces[p];\n          _parseNs(nsNamespace);\n        }\n      };\n      _parseNs(jake.defaultNamespace);\n    };\n\n    /**\n     * Displays the list of descriptions avaliable for tasks defined in\n     * a Jakefile\n     */\n    this.showAllTaskDescriptions = function (f) {\n      let p;\n      let maxTaskNameLength = 0;\n      let task;\n      let padding;\n      let name;\n      let descr;\n      let filter = typeof f == 'string' ? f : null;\n\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n        task = jake.Task[p];\n        // Record the length of the longest task name -- used for\n        // pretty alignment of the task descriptions\n        if (task.description) {\n          maxTaskNameLength = p.length > maxTaskNameLength ?\n            p.length : maxTaskNameLength;\n        }\n      }\n      // Print out each entry with descriptions neatly aligned\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n        task = jake.Task[p];\n\n        //name = '\\033[32m' + p + '\\033[39m ';\n        name = chalk.green(p);\n\n        descr = task.description;\n        if (descr) {\n          descr = chalk.gray('# ' + descr);\n\n          // Create padding-string with calculated length\n          padding = (new Array(maxTaskNameLength - p.length + 2)).join(' ');\n\n          console.log('jake ' + name + padding + descr);\n        }\n      }\n    };\n\n    this.createTask = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let arg;\n      let obj;\n      let task;\n      let type;\n      let name;\n      let action;\n      let opts = {};\n      let prereqs = [];\n\n      type = args.shift();\n\n      // name, [deps], [action]\n      // Name (string) + deps (array) format\n      if (typeof args[0] == 'string') {\n        name = args.shift();\n        if (Array.isArray(args[0])) {\n          prereqs = args.shift();\n        }\n      }\n      // name:deps, [action]\n      // Legacy object-literal syntax, e.g.: {'name': ['depA', 'depB']}\n      else {\n        obj = args.shift();\n        for (let p in obj) {\n          prereqs = prereqs.concat(obj[p]);\n          name = p;\n        }\n      }\n\n      // Optional opts/callback or callback/opts\n      while ((arg = args.shift())) {\n        if (typeof arg == 'function') {\n          action = arg;\n        }\n        else {\n          opts = Object.assign(Object.create(null), arg);\n        }\n      }\n\n      task = jake.currentNamespace.resolveTask(name);\n      if (task && !action) {\n        // Task already exists and no action, just update prereqs, and return it.\n        task.prereqs = task.prereqs.concat(prereqs);\n        return task;\n      }\n\n      switch (type) {\n      case 'directory':\n        action = function () {\n          jake.mkdirP(name);\n        };\n        task = new DirectoryTask(name, prereqs, action, opts);\n        break;\n      case 'file':\n        task = new FileTask(name, prereqs, action, opts);\n        break;\n      default:\n        task = new Task(name, prereqs, action, opts);\n      }\n\n      jake.currentNamespace.addTask(task);\n\n      if (jake.currentTaskDescription) {\n        task.description = jake.currentTaskDescription;\n        jake.currentTaskDescription = null;\n      }\n\n      // FIXME: Should only need to add a new entry for the current\n      // task-definition, not reparse the entire structure\n      jake.parseAllTasks();\n\n      return task;\n    };\n\n    this.attemptRule = function (name, ns, level) {\n      let prereqRule;\n      let prereq;\n      if (level > MAX_RULE_RECURSION_LEVEL) {\n        return null;\n      }\n      // Check Rule\n      prereqRule = ns.matchRule(name);\n      if (prereqRule) {\n        prereq = prereqRule.createTask(name, level);\n      }\n      return prereq || null;\n    };\n\n    this.createPlaceholderFileTask = function (name, namespace) {\n      let parsed = name.split(':');\n      let filePath = parsed.pop(); // Strip any namespace\n      let task;\n\n      task = namespace.resolveTask(name);\n\n      // If there's not already an existing dummy FileTask for it,\n      // create one\n      if (!task) {\n        // Create a dummy FileTask only if file actually exists\n        if (fs.existsSync(filePath)) {\n          task = new jake.FileTask(filePath);\n          task.dummy = true;\n          let ns;\n          if (parsed.length) {\n            ns = namespace.resolveNamespace(parsed.join(':'));\n          }\n          else {\n            ns = namespace;\n          }\n          if (!namespace) {\n            throw new Error('Invalid namespace, cannot add FileTask');\n          }\n          ns.addTask(task);\n          // Put this dummy Task in the global Tasks list so\n          // modTime will be eval'd correctly\n          jake.Task[`${ns.path}:${filePath}`] = task;\n        }\n      }\n\n      return task || null;\n    };\n\n\n    this.run = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let program = this.program;\n      let loader = this.loader;\n      let preempt;\n      let opts;\n\n      program.parseArgs(args);\n      program.init();\n\n      preempt = program.firstPreemptiveOption();\n      if (preempt) {\n        preempt();\n      }\n      else {\n        opts = program.opts;\n        // jakefile flag set but no jakefile yet\n        if (opts.autocomplete && opts.jakefile === true) {\n          process.stdout.write('no-complete');\n          return;\n        }\n        // Load Jakefile and jakelibdir files\n        let jakefileLoaded = loader.loadFile(opts.jakefile);\n        let jakelibdirLoaded = loader.loadDirectory(opts.jakelibdir);\n\n        if(!jakefileLoaded && !jakelibdirLoaded && !opts.autocomplete) {\n          fail('No Jakefile. Specify a valid path with -f/--jakefile, ' +\n              'or place one in the current directory.');\n        }\n\n        program.run();\n      }\n    };\n\n  })());\n}\n\nmodule.exports = jake;\n"]},"metadata":{},"sourceType":"module"}