{"ast":null,"code":"/**\n * Accepts a function that is called when the promise is canceled.\n *\n * You're not required to call this function. You can call this function multiple times to add multiple cancel handlers.\n */\n\n/**\n * Rejection reason when `.cancel()` is called.\n *\n * It includes a `.isCanceled` property for convenience.\n */\nexport class CancelError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.name = void 0;\n    this.isCanceled = void 0;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/p-cancelable/index.d.ts"],"names":["CancelError","Error","name","isCanceled"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAyJA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,WAAN,SAA0BC,KAA1B,CAAgC;AAAA;AAAA;AAAA,SAC7BC,IAD6B;AAAA,SAE7BC,UAF6B;AAAA;;AAAA","sourcesContent":["/**\n * Accepts a function that is called when the promise is canceled.\n *\n * You're not required to call this function. You can call this function multiple times to add multiple cancel handlers.\n */\nexport interface OnCancelFunction {\n\t(cancelHandler: () => void): void;\n\tshouldReject: boolean;\n}\n\ndeclare class PCancelable<ValueType> extends Promise<ValueType> {\n\t/**\n\t * Convenience method to make your promise-returning or async function cancelable.\n\t *\n\t * @param fn - A promise-returning function. The function you specify will have `onCancel` appended to its parameters.\n\t *\n\t * @example\n\t *\n\t * import PCancelable from 'p-cancelable';\n\t *\n\t * const fn = PCancelable.fn((input, onCancel) => {\n\t * \tconst job = new Job();\n\t *\n\t * \tonCancel(() => {\n\t * \t\tjob.cleanup();\n\t * \t});\n\t *\n\t * \treturn job.start(); //=> Promise\n\t * });\n\t *\n\t * const cancelablePromise = fn('input'); //=> PCancelable\n\t *\n\t * // â€¦\n\t *\n\t * cancelablePromise.cancel();\n\t */\n\tstatic fn<ReturnType>(\n\t\tuserFn: (onCancel: OnCancelFunction) => PromiseLike<ReturnType>\n\t): () => PCancelable<ReturnType>;\n\tstatic fn<Agument1Type, ReturnType>(\n\t\tuserFn: (\n\t\t\targument1: Agument1Type,\n\t\t\tonCancel: OnCancelFunction\n\t\t) => PromiseLike<ReturnType>\n\t): (argument1: Agument1Type) => PCancelable<ReturnType>;\n\tstatic fn<Agument1Type, Agument2Type, ReturnType>(\n\t\tuserFn: (\n\t\t\targument1: Agument1Type,\n\t\t\targument2: Agument2Type,\n\t\t\tonCancel: OnCancelFunction\n\t\t) => PromiseLike<ReturnType>\n\t): (\n\t\targument1: Agument1Type,\n\t\targument2: Agument2Type\n\t) => PCancelable<ReturnType>;\n\tstatic fn<Agument1Type, Agument2Type, Agument3Type, ReturnType>(\n\t\tuserFn: (\n\t\t\targument1: Agument1Type,\n\t\t\targument2: Agument2Type,\n\t\t\targument3: Agument3Type,\n\t\t\tonCancel: OnCancelFunction\n\t\t) => PromiseLike<ReturnType>\n\t): (\n\t\targument1: Agument1Type,\n\t\targument2: Agument2Type,\n\t\targument3: Agument3Type\n\t) => PCancelable<ReturnType>;\n\tstatic fn<Agument1Type, Agument2Type, Agument3Type, Agument4Type, ReturnType>(\n\t\tuserFn: (\n\t\t\targument1: Agument1Type,\n\t\t\targument2: Agument2Type,\n\t\t\targument3: Agument3Type,\n\t\t\targument4: Agument4Type,\n\t\t\tonCancel: OnCancelFunction\n\t\t) => PromiseLike<ReturnType>\n\t): (\n\t\targument1: Agument1Type,\n\t\targument2: Agument2Type,\n\t\targument3: Agument3Type,\n\t\targument4: Agument4Type\n\t) => PCancelable<ReturnType>;\n\tstatic fn<\n\t\tAgument1Type,\n\t\tAgument2Type,\n\t\tAgument3Type,\n\t\tAgument4Type,\n\t\tAgument5Type,\n\t\tReturnType\n\t>(\n\t\tuserFn: (\n\t\t\targument1: Agument1Type,\n\t\t\targument2: Agument2Type,\n\t\t\targument3: Agument3Type,\n\t\t\targument4: Agument4Type,\n\t\t\targument5: Agument5Type,\n\t\t\tonCancel: OnCancelFunction\n\t\t) => PromiseLike<ReturnType>\n\t): (\n\t\targument1: Agument1Type,\n\t\targument2: Agument2Type,\n\t\targument3: Agument3Type,\n\t\targument4: Agument4Type,\n\t\targument5: Agument5Type\n\t) => PCancelable<ReturnType>;\n\tstatic fn<ReturnType>(\n\t\tuserFn: (...arguments: unknown[]) => PromiseLike<ReturnType>\n\t): (...arguments: unknown[]) => PCancelable<ReturnType>;\n\n\t/**\n\t * Create a promise that can be canceled.\n\t *\n\t * Can be constructed in the same was as a [`Promise` constructor](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise), but with an appended `onCancel` parameter in `executor`. `PCancelable` is a subclass of `Promise`.\n\t *\n\t * Cancelling will reject the promise with `CancelError`. To avoid that, set `onCancel.shouldReject` to `false`.\n\t *\n\t * @example\n\t *\n\t * import PCancelable from 'p-cancelable';\n\t *\n\t * const cancelablePromise = new PCancelable((resolve, reject, onCancel) => {\n\t * \tconst job = new Job();\n\t *\n\t * \tonCancel.shouldReject = false;\n\t * \tonCancel(() => {\n\t * \t\tjob.stop();\n\t * \t});\n\t *\n\t * \tjob.on('finish', resolve);\n\t * });\n\t *\n\t * cancelablePromise.cancel(); // Doesn't throw an error\n\t */\n\tconstructor(\n\t\texecutor: (\n\t\t\tresolve: (value?: ValueType | PromiseLike<ValueType>) => void,\n\t\t\treject: (reason?: unknown) => void,\n\t\t\tonCancel: OnCancelFunction\n\t\t) => void\n\t);\n\n\t/**\n\t * Whether the promise is canceled.\n\t */\n\treadonly isCanceled: boolean;\n\n\t/**\n\t * Cancel the promise and optionally provide a reason.\n\t *\n\t * The cancellation is synchronous. Calling it after the promise has settled or multiple times does nothing.\n\t *\n\t * @param reason - The cancellation reason to reject the promise with.\n\t */\n\tcancel(reason?: string): void;\n}\n\nexport default PCancelable;\n\n/**\n * Rejection reason when `.cancel()` is called.\n *\n * It includes a `.isCanceled` property for convenience.\n */\nexport class CancelError extends Error {\n\treadonly name: 'CancelError';\n\treadonly isCanceled: true;\n\n\tconstructor(reason?: string);\n}\n"]},"metadata":{},"sourceType":"module"}