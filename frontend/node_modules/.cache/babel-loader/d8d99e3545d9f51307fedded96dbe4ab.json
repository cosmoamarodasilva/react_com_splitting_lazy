{"ast":null,"code":"let fs = require('fs');\n\nlet Task = require('./task').Task;\n\nfunction isFileOrDirectory(t) {\n  return t instanceof FileTask || t instanceof DirectoryTask;\n}\n\nfunction isFile(t) {\n  return t instanceof FileTask && !(t instanceof DirectoryTask);\n}\n/**\n  @name jake\n  @namespace jake\n*/\n\n/**\n  @name jake.FileTask\n  @class`\n  @extentds Task\n  @description A Jake FileTask\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform to create this file\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\n\n\nclass FileTask extends Task {\n  constructor(...args) {\n    super(...args);\n    this.dummy = false;\n\n    if (fs.existsSync(this.name)) {\n      this.updateModTime();\n    } else {\n      this.modTime = null;\n    }\n  }\n\n  isNeeded() {\n    let prereqs = this.prereqs;\n    let prereqName;\n    let prereqTask; // No repeatsies\n\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      return false;\n    } // The always-make override\n    else if (jake.program.opts['always-make']) {\n        return true;\n      } // Default case\n      else {\n          // We need either an existing file, or an action to create one.\n          // First try grabbing the actual mod-time of the file\n          try {\n            this.updateModTime();\n          } // Then fall back to looking for an action\n          catch (e) {\n            if (typeof this.action == 'function') {\n              return true;\n            } else {\n              throw new Error('File-task ' + this.fullName + ' has no ' + 'existing file, and no action to create one.');\n            }\n          } // Compare mod-time of all the prereqs with its mod-time\n          // If any prereqs are newer, need to run the action to update\n\n\n          if (prereqs && prereqs.length) {\n            for (let i = 0, ii = prereqs.length; i < ii; i++) {\n              prereqName = prereqs[i];\n              prereqTask = this.namespace.resolveTask(prereqName) || jake.createPlaceholderFileTask(prereqName, this.namespace); // Run the action if:\n              // 1. The prereq is a normal task (not file/dir)\n              // 2. The prereq is a file-task with a mod-date more recent than\n              // the one for this file/dir\n\n              if (prereqTask) {\n                if (!isFileOrDirectory(prereqTask) || isFile(prereqTask) && prereqTask.modTime > this.modTime) {\n                  return true;\n                }\n              }\n            }\n          } // File/dir has no prereqs, and exists -- no need to run\n          else {\n              // Effectively done\n              this.taskStatus = Task.runStatuses.DONE;\n              return false;\n            }\n        }\n  }\n\n  updateModTime() {\n    let stats = fs.statSync(this.name);\n    this.modTime = stats.mtime;\n  }\n\n  complete() {\n    if (!this.dummy) {\n      this.updateModTime();\n    } // Hackity hack\n\n\n    Task.prototype.complete.apply(this, arguments);\n  }\n\n}\n\nexports.FileTask = FileTask; // DirectoryTask is a subclass of FileTask, depends on it\n// being defined\n\nlet DirectoryTask = require('./directory_task').DirectoryTask;","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/task/file_task.js"],"names":["fs","require","Task","isFileOrDirectory","t","FileTask","DirectoryTask","isFile","constructor","args","dummy","existsSync","name","updateModTime","modTime","isNeeded","prereqs","prereqName","prereqTask","taskStatus","runStatuses","DONE","jake","program","opts","e","action","Error","fullName","length","i","ii","namespace","resolveTask","createPlaceholderFileTask","stats","statSync","mtime","complete","prototype","apply","arguments","exports"],"mappings":"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","sourcesContent":["let fs = require('fs');\nlet Task = require('./task').Task;\n\nfunction isFileOrDirectory(t) {\n  return (t instanceof FileTask ||\n          t instanceof DirectoryTask);\n}\n\nfunction isFile(t) {\n  return (t instanceof FileTask && !(t instanceof DirectoryTask));\n}\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.FileTask\n  @class`\n  @extentds Task\n  @description A Jake FileTask\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform to create this file\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nclass FileTask extends Task {\n  constructor(...args) {\n    super(...args);\n    this.dummy = false;\n    if (fs.existsSync(this.name)) {\n      this.updateModTime();\n    }\n    else {\n      this.modTime = null;\n    }\n  }\n\n  isNeeded() {\n    let prereqs = this.prereqs;\n    let prereqName;\n    let prereqTask;\n\n    // No repeatsies\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      return false;\n    }\n    // The always-make override\n    else if (jake.program.opts['always-make']) {\n      return true;\n    }\n    // Default case\n    else {\n\n      // We need either an existing file, or an action to create one.\n      // First try grabbing the actual mod-time of the file\n      try {\n        this.updateModTime();\n      }\n      // Then fall back to looking for an action\n      catch(e) {\n        if (typeof this.action == 'function') {\n          return true;\n        }\n        else {\n          throw new Error('File-task ' + this.fullName + ' has no ' +\n            'existing file, and no action to create one.');\n        }\n      }\n\n      // Compare mod-time of all the prereqs with its mod-time\n      // If any prereqs are newer, need to run the action to update\n      if (prereqs && prereqs.length) {\n        for (let i = 0, ii = prereqs.length; i < ii; i++) {\n          prereqName = prereqs[i];\n          prereqTask = this.namespace.resolveTask(prereqName) ||\n            jake.createPlaceholderFileTask(prereqName, this.namespace);\n          // Run the action if:\n          // 1. The prereq is a normal task (not file/dir)\n          // 2. The prereq is a file-task with a mod-date more recent than\n          // the one for this file/dir\n          if (prereqTask) {\n            if (!isFileOrDirectory(prereqTask) ||\n                (isFile(prereqTask) && prereqTask.modTime > this.modTime)) {\n              return true;\n            }\n          }\n        }\n      }\n      // File/dir has no prereqs, and exists -- no need to run\n      else {\n        // Effectively done\n        this.taskStatus = Task.runStatuses.DONE;\n        return false;\n      }\n    }\n  }\n\n  updateModTime() {\n    let stats = fs.statSync(this.name);\n    this.modTime = stats.mtime;\n  }\n\n  complete() {\n    if (!this.dummy) {\n      this.updateModTime();\n    }\n    // Hackity hack\n    Task.prototype.complete.apply(this, arguments);\n  }\n\n}\n\nexports.FileTask = FileTask;\n\n// DirectoryTask is a subclass of FileTask, depends on it\n// being defined\nlet DirectoryTask = require('./directory_task').DirectoryTask;\n\n"]},"metadata":{},"sourceType":"module"}