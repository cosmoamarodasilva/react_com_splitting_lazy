{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet path = require('path');\n\nlet fs = require('fs');\n\nlet exec = require('child_process').exec;\n\nlet FileList = require('filelist').FileList;\n/**\n  @name jake\n  @namespace jake\n*/\n\n/**\n  @name jake.PackageTask\n  @constructor\n  @description Instantiating a PackageTask creates a number of Jake\n  Tasks that make packaging and distributing your software easy.\n\n  @param {String} name The name of the project\n  @param {String} version The current project version (will be\n  appended to the project-name in the package-archive\n  @param {Function} definition Defines the contents of the package,\n  and format of the package-archive. Will be executed on the instantiated\n  PackageTask (i.e., 'this', will be the PackageTask instance),\n  to set the various instance-propertiess.\n\n  @example\n  let t = new jake.PackageTask('rous', 'v' + version, function () {\n    let files = [\n      'Capfile'\n    , 'Jakefile'\n    , 'README.md'\n    , 'package.json'\n    , 'app/*'\n    , 'bin/*'\n    , 'config/*'\n    , 'lib/*'\n    , 'node_modules/*'\n    ];\n    this.packageFiles.include(files);\n    this.packageFiles.exclude('node_modules/foobar');\n    this.needTarGz = true;\n  });\n\n */\n\n\nlet PackageTask = function () {\n  let args = Array.prototype.slice.call(arguments);\n  let name = args.shift();\n  let version = args.shift();\n  let definition = args.pop();\n  let prereqs = args.pop() || []; // Optional\n\n  prereqs = [].concat(prereqs); // Accept string or list\n\n  /**\n    @name jake.PackageTask#name\n    @public\n    @type {String}\n    @description The name of the project\n   */\n\n  this.name = name;\n  /**\n    @name jake.PackageTask#version\n    @public\n    @type {String}\n    @description The project version-string\n   */\n\n  this.version = version;\n  /**\n    @name jake.PackageTask#prereqs\n    @public\n    @type {Array}\n    @description Tasks to run before packaging\n   */\n\n  this.prereqs = prereqs;\n  /**\n    @name jake.PackageTask#packageDir\n    @public\n    @type {String='pkg'}\n    @description The directory-name to use for packaging the software\n   */\n\n  this.packageDir = 'pkg';\n  /**\n    @name jake.PackageTask#packageFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files and directories to include in the\n    package-archive\n   */\n\n  this.packageFiles = new FileList();\n  /**\n    @name jake.PackageTask#needTar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tgz archive of the package\n   */\n\n  this.needTar = false;\n  /**\n    @name jake.PackageTask#needTarGz\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tar.gz archive of the package\n   */\n\n  this.needTarGz = false;\n  /**\n    @name jake.PackageTask#needTarBz2\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a bzip2 .bz2 archive of the package\n   */\n\n  this.needTarBz2 = false;\n  /**\n    @name jake.PackageTask#needJar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `jar` utility to create\n    a .jar archive of the package\n   */\n\n  this.needJar = false;\n  /**\n    @name jake.PackageTask#needZip\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `zip` utility to create\n    a .zip archive of the package\n   */\n\n  this.needZip = false;\n  /**\n    @name jake.PackageTask#manifestFile\n    @public\n    @type {String=null}\n    @description Can be set to point the `jar` utility at a manifest\n    file to use in a .jar archive. If unset, one will be automatically\n    created by the `jar` utility. This path should be relative to the\n    root of the package directory (this.packageDir above, likely 'pkg')\n   */\n\n  this.manifestFile = null;\n  /**\n    @name jake.PackageTask#tarCommand\n    @public\n    @type {String='tar'}\n    @description The shell-command to use for creating tar archives.\n   */\n\n  this.tarCommand = 'tar';\n  /**\n    @name jake.PackageTask#jarCommand\n    @public\n    @type {String='jar'}\n    @description The shell-command to use for creating jar archives.\n   */\n\n  this.jarCommand = 'jar';\n  /**\n    @name jake.PackageTask#zipCommand\n    @public\n    @type {String='zip'}\n    @description The shell-command to use for creating zip archives.\n   */\n\n  this.zipCommand = 'zip';\n  /**\n    @name jake.PackageTask#archiveNoBaseDir\n    @public\n    @type {Boolean=false}\n    @description Simple option for performing the archive on the\n    contents of the directory instead of the directory itself\n   */\n\n  this.archiveNoBaseDir = false;\n  /**\n    @name jake.PackageTask#archiveChangeDir\n    @public\n    @type {String=null}\n    @description Equivalent to the '-C' command for the `tar` and `jar`\n    commands. (\"Change to this directory before adding files.\")\n   */\n\n  this.archiveChangeDir = null;\n  /**\n    @name jake.PackageTask#archiveContentDir\n    @public\n    @type {String=null}\n    @description Specifies the files and directories to include in the\n    package-archive. If unset, this will default to the main package\n    directory -- i.e., name + version.\n   */\n\n  this.archiveContentDir = null;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n\n  this.define();\n};\n\n_c = PackageTask;\nPackageTask.prototype = new function () {\n  let _compressOpts = {\n    Tar: {\n      ext: '.tgz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarGz: {\n      ext: '.tar.gz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarBz2: {\n      ext: '.tar.bz2',\n      flags: 'cjf',\n      cmd: 'tar'\n    },\n    Jar: {\n      ext: '.jar',\n      flags: 'cf',\n      cmd: 'jar'\n    },\n    Zip: {\n      ext: '.zip',\n      flags: 'qr',\n      cmd: 'zip'\n    }\n  };\n\n  this.define = function () {\n    let self = this;\n    let packageDirPath = this.packageDirPath();\n    let compressTaskArr = [];\n    desc('Build the package for distribution');\n    task('package', self.prereqs.concat(['clobberPackage', 'buildPackage'])); // Backward-compat alias\n\n    task('repackage', ['package']);\n    task('clobberPackage', function () {\n      jake.rmRf(self.packageDir, {\n        silent: true\n      });\n    });\n    desc('Remove the package');\n    task('clobber', ['clobberPackage']);\n\n    let doCommand = function (p) {\n      let filename = path.resolve(self.packageDir + '/' + self.packageName() + _compressOpts[p].ext);\n\n      if (process.platform == 'win32') {\n        // Windows full path may have drive letter, which is going to cause\n        // namespace problems, so strip it.\n        if (filename.length > 2 && filename[1] == ':') {\n          filename = filename.substr(2);\n        }\n      }\n\n      compressTaskArr.push(filename);\n      file(filename, [packageDirPath], function () {\n        let cmd;\n        let opts = _compressOpts[p]; // Directory to move to when doing the compression-task\n        // Changes in the case of zip for emulating -C option\n\n        let chdir = self.packageDir; // Save the current dir so it's possible to pop back up\n        // after compressing\n\n        let currDir = process.cwd();\n        let archiveChangeDir;\n        let archiveContentDir;\n\n        if (self.archiveNoBaseDir) {\n          archiveChangeDir = self.packageName();\n          archiveContentDir = '.';\n        } else {\n          archiveChangeDir = self.archiveChangeDir;\n          archiveContentDir = self.archiveContentDir;\n        }\n\n        cmd = self[opts.cmd + 'Command'];\n        cmd += ' -' + opts.flags;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += 'm';\n        } // The name of the archive to create -- use full path\n        // so compression can be performed from a different dir\n        // if needed\n\n\n        cmd += ' ' + filename;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += ' ' + self.manifestFile;\n        } // Where to perform the compression -- -C option isn't\n        // supported in zip, so actually do process.chdir for this\n\n\n        if (archiveChangeDir) {\n          if (opts.cmd == 'zip') {\n            chdir = path.join(chdir, archiveChangeDir);\n          } else {\n            cmd += ' -C ' + archiveChangeDir;\n          }\n        } // Where to get the archive content\n\n\n        if (archiveContentDir) {\n          cmd += ' ' + archiveContentDir;\n        } else {\n          cmd += ' ' + self.packageName();\n        } // Move into the desired dir (usually packageDir) to compress\n        // Return back up to the current dir after the exec\n\n\n        process.chdir(chdir);\n        exec(cmd, function (err, stdout, stderr) {\n          if (err) {\n            throw err;\n          } // Return back up to the starting directory (see above,\n          // before exec)\n\n\n          process.chdir(currDir);\n          complete();\n        });\n      }, {\n        async: true\n      });\n    };\n\n    for (let p in _compressOpts) {\n      if (this['need' + p]) {\n        doCommand(p);\n      }\n    }\n\n    task('buildPackage', compressTaskArr, function () {});\n    directory(this.packageDir);\n    file(packageDirPath, this.packageFiles, function () {\n      jake.mkdirP(packageDirPath);\n      let fileList = [];\n      self.packageFiles.forEach(function (name) {\n        let f = path.join(self.packageDirPath(), name);\n        let fDir = path.dirname(f);\n        jake.mkdirP(fDir, {\n          silent: true\n        }); // Add both files and directories\n\n        fileList.push({\n          from: name,\n          to: f\n        });\n      });\n\n      let _copyFile = function () {\n        let file = fileList.pop();\n        let stat;\n\n        if (file) {\n          stat = fs.statSync(file.from); // Target is a directory, just create it\n\n          if (stat.isDirectory()) {\n            jake.mkdirP(file.to, {\n              silent: true\n            });\n\n            _copyFile();\n          } // Otherwise copy the file\n          else {\n              jake.cpR(file.from, file.to, {\n                silent: true\n              });\n\n              _copyFile();\n            }\n        } else {\n          complete();\n        }\n      };\n\n      _copyFile();\n    }, {\n      async: true\n    });\n  };\n\n  this.packageName = function () {\n    if (this.version) {\n      return this.name + '-' + this.version;\n    } else {\n      return this.name;\n    }\n  };\n\n  this.packageDirPath = function () {\n    return this.packageDir + '/' + this.packageName();\n  };\n}();\njake.PackageTask = PackageTask;\nexports.PackageTask = PackageTask;\n\nvar _c;\n\n$RefreshReg$(_c, \"PackageTask\");","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/package_task.js"],"names":["path","require","fs","exec","FileList","PackageTask","args","Array","prototype","slice","call","arguments","name","shift","version","definition","pop","prereqs","concat","packageDir","packageFiles","needTar","needTarGz","needTarBz2","needJar","needZip","manifestFile","tarCommand","jarCommand","zipCommand","archiveNoBaseDir","archiveChangeDir","archiveContentDir","define","_compressOpts","Tar","ext","flags","cmd","TarGz","TarBz2","Jar","Zip","self","packageDirPath","compressTaskArr","desc","task","jake","rmRf","silent","doCommand","p","filename","resolve","packageName","process","platform","length","substr","push","file","opts","chdir","currDir","cwd","join","err","stdout","stderr","complete","async","directory","mkdirP","fileList","forEach","f","fDir","dirname","from","to","_copyFile","stat","statSync","isDirectory","cpR","exports"],"mappings":"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","sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet path = require('path');\nlet fs = require('fs');\nlet exec = require('child_process').exec;\nlet FileList = require('filelist').FileList;\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.PackageTask\n  @constructor\n  @description Instantiating a PackageTask creates a number of Jake\n  Tasks that make packaging and distributing your software easy.\n\n  @param {String} name The name of the project\n  @param {String} version The current project version (will be\n  appended to the project-name in the package-archive\n  @param {Function} definition Defines the contents of the package,\n  and format of the package-archive. Will be executed on the instantiated\n  PackageTask (i.e., 'this', will be the PackageTask instance),\n  to set the various instance-propertiess.\n\n  @example\n  let t = new jake.PackageTask('rous', 'v' + version, function () {\n    let files = [\n      'Capfile'\n    , 'Jakefile'\n    , 'README.md'\n    , 'package.json'\n    , 'app/*'\n    , 'bin/*'\n    , 'config/*'\n    , 'lib/*'\n    , 'node_modules/*'\n    ];\n    this.packageFiles.include(files);\n    this.packageFiles.exclude('node_modules/foobar');\n    this.needTarGz = true;\n  });\n\n */\nlet PackageTask = function () {\n  let args = Array.prototype.slice.call(arguments);\n  let name = args.shift();\n  let version = args.shift();\n  let definition = args.pop();\n  let prereqs = args.pop() || []; // Optional\n\n  prereqs = [].concat(prereqs); // Accept string or list\n\n  /**\n    @name jake.PackageTask#name\n    @public\n    @type {String}\n    @description The name of the project\n   */\n  this.name = name;\n  /**\n    @name jake.PackageTask#version\n    @public\n    @type {String}\n    @description The project version-string\n   */\n  this.version = version;\n  /**\n    @name jake.PackageTask#prereqs\n    @public\n    @type {Array}\n    @description Tasks to run before packaging\n   */\n  this.prereqs = prereqs;\n  /**\n    @name jake.PackageTask#packageDir\n    @public\n    @type {String='pkg'}\n    @description The directory-name to use for packaging the software\n   */\n  this.packageDir = 'pkg';\n  /**\n    @name jake.PackageTask#packageFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files and directories to include in the\n    package-archive\n   */\n  this.packageFiles = new FileList();\n  /**\n    @name jake.PackageTask#needTar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tgz archive of the package\n   */\n  this.needTar = false;\n  /**\n    @name jake.PackageTask#needTarGz\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tar.gz archive of the package\n   */\n  this.needTarGz = false;\n  /**\n    @name jake.PackageTask#needTarBz2\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a bzip2 .bz2 archive of the package\n   */\n  this.needTarBz2 = false;\n  /**\n    @name jake.PackageTask#needJar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `jar` utility to create\n    a .jar archive of the package\n   */\n  this.needJar = false;\n  /**\n    @name jake.PackageTask#needZip\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `zip` utility to create\n    a .zip archive of the package\n   */\n  this.needZip = false;\n  /**\n    @name jake.PackageTask#manifestFile\n    @public\n    @type {String=null}\n    @description Can be set to point the `jar` utility at a manifest\n    file to use in a .jar archive. If unset, one will be automatically\n    created by the `jar` utility. This path should be relative to the\n    root of the package directory (this.packageDir above, likely 'pkg')\n   */\n  this.manifestFile = null;\n  /**\n    @name jake.PackageTask#tarCommand\n    @public\n    @type {String='tar'}\n    @description The shell-command to use for creating tar archives.\n   */\n  this.tarCommand = 'tar';\n  /**\n    @name jake.PackageTask#jarCommand\n    @public\n    @type {String='jar'}\n    @description The shell-command to use for creating jar archives.\n   */\n  this.jarCommand = 'jar';\n  /**\n    @name jake.PackageTask#zipCommand\n    @public\n    @type {String='zip'}\n    @description The shell-command to use for creating zip archives.\n   */\n  this.zipCommand = 'zip';\n  /**\n    @name jake.PackageTask#archiveNoBaseDir\n    @public\n    @type {Boolean=false}\n    @description Simple option for performing the archive on the\n    contents of the directory instead of the directory itself\n   */\n  this.archiveNoBaseDir = false;\n  /**\n    @name jake.PackageTask#archiveChangeDir\n    @public\n    @type {String=null}\n    @description Equivalent to the '-C' command for the `tar` and `jar`\n    commands. (\"Change to this directory before adding files.\")\n   */\n  this.archiveChangeDir = null;\n  /**\n    @name jake.PackageTask#archiveContentDir\n    @public\n    @type {String=null}\n    @description Specifies the files and directories to include in the\n    package-archive. If unset, this will default to the main package\n    directory -- i.e., name + version.\n   */\n  this.archiveContentDir = null;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n  this.define();\n};\n\nPackageTask.prototype = new (function () {\n\n  let _compressOpts = {\n    Tar: {\n      ext: '.tgz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarGz: {\n      ext: '.tar.gz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarBz2: {\n      ext: '.tar.bz2',\n      flags: 'cjf',\n      cmd: 'tar'\n    },\n    Jar: {\n      ext: '.jar',\n      flags: 'cf',\n      cmd: 'jar'\n    },\n    Zip: {\n      ext: '.zip',\n      flags: 'qr',\n      cmd: 'zip'\n    }\n  };\n\n  this.define = function () {\n    let self = this;\n    let packageDirPath = this.packageDirPath();\n    let compressTaskArr = [];\n\n    desc('Build the package for distribution');\n    task('package', self.prereqs.concat(['clobberPackage', 'buildPackage']));\n    // Backward-compat alias\n    task('repackage', ['package']);\n\n    task('clobberPackage', function () {\n      jake.rmRf(self.packageDir, {silent: true});\n    });\n\n    desc('Remove the package');\n    task('clobber', ['clobberPackage']);\n\n    let doCommand = function (p) {\n      let filename = path.resolve(self.packageDir + '/' + self.packageName() +\n                                  _compressOpts[p].ext);\n      if (process.platform == 'win32') {\n        // Windows full path may have drive letter, which is going to cause\n        // namespace problems, so strip it.\n        if (filename.length > 2 && filename[1] == ':') {\n          filename = filename.substr(2);\n        }\n      }\n      compressTaskArr.push(filename);\n\n      file(filename, [packageDirPath], function () {\n        let cmd;\n        let opts = _compressOpts[p];\n        // Directory to move to when doing the compression-task\n        // Changes in the case of zip for emulating -C option\n        let chdir = self.packageDir;\n        // Save the current dir so it's possible to pop back up\n        // after compressing\n        let currDir = process.cwd();\n        let archiveChangeDir;\n        let archiveContentDir;\n\n        if (self.archiveNoBaseDir) {\n          archiveChangeDir = self.packageName();\n          archiveContentDir = '.';\n        }\n        else {\n          archiveChangeDir = self.archiveChangeDir;\n          archiveContentDir = self.archiveContentDir;\n        }\n\n        cmd = self[opts.cmd + 'Command'];\n        cmd += ' -' + opts.flags;\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += 'm';\n        }\n\n        // The name of the archive to create -- use full path\n        // so compression can be performed from a different dir\n        // if needed\n        cmd += ' ' + filename;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += ' ' + self.manifestFile;\n        }\n\n        // Where to perform the compression -- -C option isn't\n        // supported in zip, so actually do process.chdir for this\n        if (archiveChangeDir) {\n          if (opts.cmd == 'zip') {\n            chdir = path.join(chdir, archiveChangeDir);\n          }\n          else {\n            cmd += ' -C ' + archiveChangeDir;\n          }\n        }\n\n        // Where to get the archive content\n        if (archiveContentDir) {\n          cmd += ' ' + archiveContentDir;\n        }\n        else {\n          cmd += ' ' + self.packageName();\n        }\n\n        // Move into the desired dir (usually packageDir) to compress\n        // Return back up to the current dir after the exec\n        process.chdir(chdir);\n\n        exec(cmd, function (err, stdout, stderr) {\n          if (err) { throw err; }\n\n          // Return back up to the starting directory (see above,\n          // before exec)\n          process.chdir(currDir);\n\n          complete();\n        });\n      }, {async: true});\n    };\n\n    for (let p in _compressOpts) {\n      if (this['need' + p]) {\n        doCommand(p);\n      }\n    }\n\n    task('buildPackage', compressTaskArr, function () {});\n\n    directory(this.packageDir);\n\n    file(packageDirPath, this.packageFiles, function () {\n      jake.mkdirP(packageDirPath);\n      let fileList = [];\n      self.packageFiles.forEach(function (name) {\n        let f = path.join(self.packageDirPath(), name);\n        let fDir = path.dirname(f);\n        jake.mkdirP(fDir, {silent: true});\n\n        // Add both files and directories\n        fileList.push({\n          from: name,\n          to: f\n        });\n      });\n      let _copyFile = function () {\n        let file = fileList.pop();\n        let stat;\n        if (file) {\n          stat = fs.statSync(file.from);\n          // Target is a directory, just create it\n          if (stat.isDirectory()) {\n            jake.mkdirP(file.to, {silent: true});\n            _copyFile();\n          }\n          // Otherwise copy the file\n          else {\n            jake.cpR(file.from, file.to, {silent: true});\n            _copyFile();\n          }\n        }\n        else {\n          complete();\n        }\n      };\n      _copyFile();\n    }, {async: true});\n\n\n  };\n\n  this.packageName = function () {\n    if (this.version) {\n      return this.name + '-' + this.version;\n    }\n    else {\n      return this.name;\n    }\n  };\n\n  this.packageDirPath = function () {\n    return this.packageDir + '/' + this.packageName();\n  };\n\n})();\n\njake.PackageTask = PackageTask;\nexports.PackageTask = PackageTask;\n\n"]},"metadata":{},"sourceType":"module"}