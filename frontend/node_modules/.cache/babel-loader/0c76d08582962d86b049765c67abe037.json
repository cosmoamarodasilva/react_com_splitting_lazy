{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nvar fs = require('fs'),\n    path = require('path'),\n    minimatch = require('minimatch'),\n    escapeRegExpChars,\n    merge,\n    basedir,\n    _readDir,\n    readdirR,\n    globSync;\n/**\n  @name escapeRegExpChars\n  @function\n  @return {String} A string of escaped characters\n  @description Escapes regex control-characters in strings\n               used to build regexes dynamically\n  @param {String} string The string of chars to escape\n*/\n\n\nescapeRegExpChars = function () {\n  var specials = ['^', '$', '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n  var sRE = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n  return function (string) {\n    var str = string || '';\n    str = String(str);\n    return str.replace(sRE, '\\\\$1');\n  };\n}();\n/**\n  @name merge\n  @function\n  @return {Object} Returns the merged object\n  @description Merge merges `otherObject` into `object` and takes care of deep\n               merging of objects\n  @param {Object} object Object to merge into\n  @param {Object} otherObject Object to read from\n*/\n\n\nmerge = function (object, otherObject) {\n  var obj = object || {},\n      otherObj = otherObject || {},\n      key,\n      value;\n\n  for (key in otherObj) {\n    value = otherObj[key]; // Check if a value is an Object, if so recursively add it's key/values\n\n    if (typeof value === 'object' && !(value instanceof Array)) {\n      // Update value of object to the one from otherObj\n      obj[key] = merge(obj[key], value);\n    } // Value is anything other than an Object, so just add it\n    else {\n        obj[key] = value;\n      }\n  }\n\n  return obj;\n};\n/**\n  Given a patern, return the base directory of it (ie. the folder\n  that will contain all the files matching the path).\n  eg. file.basedir('/test/**') => '/test/'\n  Path ending by '/' are considerd as folder while other are considerd\n  as files, eg.:\n      file.basedir('/test/a/') => '/test/a'\n      file.basedir('/test/a') => '/test'\n  The returned path always end with a '/' so we have:\n      file.basedir(file.basedir(x)) == file.basedir(x)\n*/\n\n\nbasedir = function (pathParam) {\n  var bd = '',\n      parts,\n      part,\n      pos = 0,\n      p = pathParam || ''; // If the path has a leading asterisk, basedir is the current dir\n\n  if (p.indexOf('*') == 0 || p.indexOf('**') == 0) {\n    return '.';\n  } // always consider .. at the end as a folder and not a filename\n\n\n  if (/(?:^|\\/|\\\\)\\.\\.$/.test(p.slice(-3))) {\n    p += '/';\n  }\n\n  parts = p.split(/\\\\|\\//);\n\n  for (var i = 0, l = parts.length - 1; i < l; i++) {\n    part = parts[i];\n\n    if (part.indexOf('*') > -1 || part.indexOf('**') > -1) {\n      break;\n    }\n\n    pos += part.length + 1;\n    bd += part + p[pos - 1];\n  }\n\n  if (!bd) {\n    bd = '.';\n  } // Strip trailing slashes\n\n\n  if (!(bd == '\\\\' || bd == '/')) {\n    bd = bd.replace(/\\\\$|\\/$/, '');\n  }\n\n  return bd;\n}; // Return the contents of a given directory\n\n\n_readDir = function (dirPath) {\n  var dir = path.normalize(dirPath),\n      paths = [],\n      ret = [dir],\n      msg;\n\n  try {\n    paths = fs.readdirSync(dir);\n  } catch (e) {\n    msg = 'Could not read path ' + dir + '\\n';\n\n    if (e.stack) {\n      msg += e.stack;\n    }\n\n    throw new Error(msg);\n  }\n\n  paths.forEach(function (p) {\n    var curr = path.join(dir, p);\n    var stat = fs.statSync(curr);\n\n    if (stat.isDirectory()) {\n      ret = ret.concat(_readDir(curr));\n    } else {\n      ret.push(curr);\n    }\n  });\n  return ret;\n};\n/**\n  @name file#readdirR\n  @function\n  @return {Array} Returns the contents as an Array, can be configured via opts.format\n  @description Reads the given directory returning it's contents\n  @param {String} dir The directory to read\n  @param {Object} opts Options to use\n    @param {String} [opts.format] Set the format to return(Default: Array)\n*/\n\n\nreaddirR = function (dir, opts) {\n  var options = opts || {},\n      format = options.format || 'array',\n      ret;\n  ret = _readDir(dir);\n  return format == 'string' ? ret.join('\\n') : ret;\n};\n\nglobSync = function (pat, opts) {\n  var dirname = basedir(pat),\n      files,\n      matches;\n\n  try {\n    files = readdirR(dirname).map(function (file) {\n      return file.replace(/\\\\/g, '/');\n    });\n  } // Bail if path doesn't exist -- assume no files\n  catch (e) {\n    console.error(e.message);\n  }\n\n  if (files) {\n    pat = path.normalize(pat);\n    matches = minimatch.match(files, pat, opts || {});\n  }\n\n  return matches || [];\n}; // Constants\n// ---------------\n// List of all the builtin Array methods we want to override\n\n\nvar ARRAY_METHODS = Object.getOwnPropertyNames(Array.prototype) // Array methods that return a copy instead of affecting the original\n,\n    SPECIAL_RETURN = {\n  'concat': true,\n  'slice': true,\n  'filter': true,\n  'map': true\n} // Default file-patterns we want to ignore\n,\n    DEFAULT_IGNORE_PATTERNS = [/(^|[\\/\\\\])CVS([\\/\\\\]|$)/, /(^|[\\/\\\\])\\.svn([\\/\\\\]|$)/, /(^|[\\/\\\\])\\.git([\\/\\\\]|$)/, /\\.bak$/, /~$/] // Ignore core files\n,\n    DEFAULT_IGNORE_FUNCS = [function (name) {\n  var isDir = false,\n      stats;\n\n  try {\n    stats = fs.statSync(name);\n    isDir = stats.isDirectory();\n  } catch (e) {}\n\n  return /(^|[\\/\\\\])core$/.test(name) && !isDir;\n}];\n\nvar FileList = function () {\n  var self = this,\n      wrap; // List of glob-patterns or specific filenames\n\n  this.pendingAdd = []; // Switched to false after lazy-eval of files\n\n  this.pending = true; // Used to calculate exclusions from the list of files\n\n  this.excludes = {\n    pats: DEFAULT_IGNORE_PATTERNS.slice(),\n    funcs: DEFAULT_IGNORE_FUNCS.slice(),\n    regex: null\n  };\n  this.items = []; // Wrap the array methods with the delegates\n\n  wrap = function (prop) {\n    var arr;\n\n    self[prop] = function () {\n      if (self.pending) {\n        self.resolve();\n      }\n\n      if (typeof self.items[prop] == 'function') {\n        // Special method that return a copy\n        if (SPECIAL_RETURN[prop]) {\n          arr = self.items[prop].apply(self.items, arguments);\n          return FileList.clone(self, arr);\n        } else {\n          return self.items[prop].apply(self.items, arguments);\n        }\n      } else {\n        return self.items[prop];\n      }\n    };\n  };\n\n  for (var i = 0, ii = ARRAY_METHODS.length; i < ii; i++) {\n    wrap(ARRAY_METHODS[i]);\n  } // Include whatever files got passed to the constructor\n\n\n  this.include.apply(this, arguments); // Fix constructor linkage\n\n  this.constructor = FileList;\n};\n\n_c = FileList;\nFileList.prototype = new function () {\n  var globPattern = /[*?\\[\\{]/;\n\n  var _addMatching = function (item) {\n    var matches = globSync(item.path, item.options);\n    this.items = this.items.concat(matches);\n  },\n      _resolveAdd = function (item) {\n    if (globPattern.test(item.path)) {\n      _addMatching.call(this, item);\n    } else {\n      this.push(item.path);\n    }\n  },\n      _calculateExcludeRe = function () {\n    var pats = this.excludes.pats,\n        pat,\n        excl = [],\n        matches = [];\n\n    for (var i = 0, ii = pats.length; i < ii; i++) {\n      pat = pats[i];\n\n      if (typeof pat == 'string') {\n        // Glob, look up files\n        if (/[*?]/.test(pat)) {\n          matches = globSync(pat);\n          matches = matches.map(function (m) {\n            return escapeRegExpChars(m);\n          });\n          excl = excl.concat(matches);\n        } // String for regex\n        else {\n            excl.push(escapeRegExpChars(pat));\n          }\n      } // Regex, grab the string-representation\n      else if (pat instanceof RegExp) {\n          excl.push(pat.toString().replace(/^\\/|\\/$/g, ''));\n        }\n    }\n\n    if (excl.length) {\n      this.excludes.regex = new RegExp('(' + excl.join(')|(') + ')');\n    } else {\n      this.excludes.regex = /^$/;\n    }\n  },\n      _resolveExclude = function () {\n    var self = this;\n\n    _calculateExcludeRe.call(this); // No `reject` method, so use reverse-filter\n\n\n    this.items = this.items.filter(function (name) {\n      return !self.shouldExclude(name);\n    });\n  };\n  /**\n   * Includes file-patterns in the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments should be strings\n   * for either a glob-pattern or a specific file-name, or an array of them\n   */\n\n\n  this.include = function () {\n    var args = Array.prototype.slice.call(arguments),\n        arg,\n        includes = {\n      items: [],\n      options: {}\n    };\n\n    for (var i = 0, ilen = args.length; i < ilen; i++) {\n      arg = args[i];\n\n      if (typeof arg === 'object' && !Array.isArray(arg)) {\n        merge(includes.options, arg);\n      } else {\n        includes.items = includes.items.concat(arg).filter(function (item) {\n          return !!item;\n        });\n      }\n    }\n\n    var items = includes.items.map(function (item) {\n      return {\n        path: item,\n        options: includes.options\n      };\n    });\n    this.pendingAdd = this.pendingAdd.concat(items);\n    return this;\n  };\n  /**\n   * Indicates whether a particular file would be filtered out by the current\n   * exclusion rules for this FileList.\n   * @param {String} name The filename to check\n   * @return {Boolean} Whether or not the file should be excluded\n   */\n\n\n  this.shouldExclude = function (name) {\n    if (!this.excludes.regex) {\n      _calculateExcludeRe.call(this);\n    }\n\n    var excl = this.excludes;\n    return excl.regex.test(name) || excl.funcs.some(function (f) {\n      return !!f(name);\n    });\n  };\n  /**\n   * Excludes file-patterns from the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments can be:\n   * 1. Strings for either a glob-pattern or a specific file-name\n   * 2. Regular expression literals\n   * 3. Functions to be run on the filename that return a true/false\n   */\n\n\n  this.exclude = function () {\n    var args = Array.isArray(arguments[0]) ? arguments[0] : arguments,\n        arg;\n\n    for (var i = 0, ii = args.length; i < ii; i++) {\n      arg = args[i];\n\n      if (typeof arg == 'function' && !(arg instanceof RegExp)) {\n        this.excludes.funcs.push(arg);\n      } else {\n        this.excludes.pats.push(arg);\n      }\n    }\n\n    if (!this.pending) {\n      _resolveExclude.call(this);\n    }\n\n    return this;\n  };\n  /**\n   * Populates the FileList from the include/exclude rules with a list of\n   * actual files\n   */\n\n\n  this.resolve = function () {\n    var item,\n        uniqueFunc = function (p, c) {\n      if (p.indexOf(c) < 0) {\n        p.push(c);\n      }\n\n      return p;\n    };\n\n    if (this.pending) {\n      this.pending = false;\n\n      while (item = this.pendingAdd.shift()) {\n        _resolveAdd.call(this, item);\n      } // Reduce to a unique list\n\n\n      this.items = this.items.reduce(uniqueFunc, []); // Remove exclusions\n\n      _resolveExclude.call(this);\n    }\n\n    return this;\n  };\n  /**\n   * Convert to a plain-jane array\n   */\n\n\n  this.toArray = function () {\n    // Call slice to ensure lazy-resolution before slicing items\n    var ret = this.slice().items.slice();\n    return ret;\n  };\n  /**\n   * Clear any pending items -- only useful before\n   * calling `resolve`\n   */\n\n\n  this.clearInclusions = function () {\n    this.pendingAdd = [];\n    return this;\n  };\n  /**\n   * Clear any current exclusion rules\n   */\n\n\n  this.clearExclusions = function () {\n    this.excludes = {\n      pats: [],\n      funcs: [],\n      regex: null\n    };\n    return this;\n  };\n}(); // Static method, used to create copy returned by special\n// array methods\n\nFileList.clone = function (list, items) {\n  var clone = new FileList();\n\n  if (items) {\n    clone.items = items;\n  }\n\n  clone.pendingAdd = list.pendingAdd;\n  clone.pending = list.pending;\n\n  for (var p in list.excludes) {\n    clone.excludes[p] = list.excludes[p];\n  }\n\n  return clone;\n};\n\nexports.FileList = FileList;\n\nvar _c;\n\n$RefreshReg$(_c, \"FileList\");","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/filelist/index.js"],"names":["fs","require","path","minimatch","escapeRegExpChars","merge","basedir","_readDir","readdirR","globSync","specials","sRE","RegExp","join","string","str","String","replace","object","otherObject","obj","otherObj","key","value","Array","pathParam","bd","parts","part","pos","p","indexOf","test","slice","split","i","l","length","dirPath","dir","normalize","paths","ret","msg","readdirSync","e","stack","Error","forEach","curr","stat","statSync","isDirectory","concat","push","opts","options","format","pat","dirname","files","matches","map","file","console","error","message","match","ARRAY_METHODS","Object","getOwnPropertyNames","prototype","SPECIAL_RETURN","DEFAULT_IGNORE_PATTERNS","DEFAULT_IGNORE_FUNCS","name","isDir","stats","FileList","self","wrap","pendingAdd","pending","excludes","pats","funcs","regex","items","prop","arr","resolve","apply","arguments","clone","ii","include","constructor","globPattern","_addMatching","item","_resolveAdd","call","_calculateExcludeRe","excl","m","toString","_resolveExclude","filter","shouldExclude","args","arg","includes","ilen","isArray","some","f","exclude","uniqueFunc","c","shift","reduce","toArray","clearInclusions","clearExclusions","list","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAhB;AAAA,IACEC,IAAI,GAAGD,OAAO,CAAC,MAAD,CADhB;AAAA,IAEEE,SAAS,GAAGF,OAAO,CAAC,WAAD,CAFrB;AAAA,IAGEG,iBAHF;AAAA,IAIEC,KAJF;AAAA,IAKEC,OALF;AAAA,IAMEC,QANF;AAAA,IAOEC,QAPF;AAAA,IAQEC,QARF;AAUE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEL,iBAAiB,GAAI,YAAY;AAC/B,MAAIM,QAAQ,GAAG,CAAE,GAAF,EAAO,GAAP,EAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,EAAgC,GAAhC,EAAqC,GAArC,EAA0C,GAA1C,EAA+C,GAA/C,EACX,GADW,EACN,GADM,EACD,GADC,EACI,GADJ,EACS,IADT,CAAf;AAEA,MAAIC,GAAG,GAAG,IAAIC,MAAJ,CAAW,QAAQF,QAAQ,CAACG,IAAT,CAAc,KAAd,CAAR,GAA+B,GAA1C,EAA+C,GAA/C,CAAV;AACA,SAAO,UAAUC,MAAV,EAAkB;AACvB,QAAIC,GAAG,GAAGD,MAAM,IAAI,EAApB;AACAC,IAAAA,GAAG,GAAGC,MAAM,CAACD,GAAD,CAAZ;AACA,WAAOA,GAAG,CAACE,OAAJ,CAAYN,GAAZ,EAAiB,MAAjB,CAAP;AACD,GAJD;AAKD,CATmB,EAApB;AAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEN,KAAK,GAAG,UAAUa,MAAV,EAAkBC,WAAlB,EAA+B;AACrC,MAAIC,GAAG,GAAGF,MAAM,IAAI,EAApB;AAAA,MACIG,QAAQ,GAAGF,WAAW,IAAI,EAD9B;AAAA,MAEIG,GAFJ;AAAA,MAESC,KAFT;;AAIA,OAAKD,GAAL,IAAYD,QAAZ,EAAsB;AACpBE,IAAAA,KAAK,GAAGF,QAAQ,CAACC,GAAD,CAAhB,CADoB,CAGpB;;AACA,QAAI,OAAOC,KAAP,KAAiB,QAAjB,IAA6B,EAAEA,KAAK,YAAYC,KAAnB,CAAjC,EAA4D;AAC1D;AACAJ,MAAAA,GAAG,CAACE,GAAD,CAAH,GAAWjB,KAAK,CAACe,GAAG,CAACE,GAAD,CAAJ,EAAWC,KAAX,CAAhB;AACD,KAHD,CAIA;AAJA,SAKK;AACHH,QAAAA,GAAG,CAACE,GAAD,CAAH,GAAWC,KAAX;AACD;AACF;;AAED,SAAOH,GAAP;AACD,CApBD;AAqBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEd,OAAO,GAAG,UAAUmB,SAAV,EAAqB;AAC7B,MAAIC,EAAE,GAAG,EAAT;AAAA,MACIC,KADJ;AAAA,MAEIC,IAFJ;AAAA,MAGIC,GAAG,GAAG,CAHV;AAAA,MAIIC,CAAC,GAAGL,SAAS,IAAI,EAJrB,CAD6B,CAO7B;;AACA,MAAIK,CAAC,CAACC,OAAF,CAAU,GAAV,KAAkB,CAAlB,IAAuBD,CAAC,CAACC,OAAF,CAAU,IAAV,KAAmB,CAA9C,EAAiD;AAC/C,WAAO,GAAP;AACD,GAV4B,CAY7B;;;AACA,MAAI,mBAAmBC,IAAnB,CAAwBF,CAAC,CAACG,KAAF,CAAQ,CAAC,CAAT,CAAxB,CAAJ,EAA0C;AACxCH,IAAAA,CAAC,IAAI,GAAL;AACD;;AAEDH,EAAAA,KAAK,GAAGG,CAAC,CAACI,KAAF,CAAQ,OAAR,CAAR;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGT,KAAK,CAACU,MAAN,GAAe,CAAnC,EAAsCF,CAAC,GAAGC,CAA1C,EAA6CD,CAAC,EAA9C,EAAkD;AAChDP,IAAAA,IAAI,GAAGD,KAAK,CAACQ,CAAD,CAAZ;;AACA,QAAIP,IAAI,CAACG,OAAL,CAAa,GAAb,IAAoB,CAAC,CAArB,IAA0BH,IAAI,CAACG,OAAL,CAAa,IAAb,IAAqB,CAAC,CAApD,EAAuD;AACrD;AACD;;AACDF,IAAAA,GAAG,IAAID,IAAI,CAACS,MAAL,GAAc,CAArB;AACAX,IAAAA,EAAE,IAAIE,IAAI,GAAGE,CAAC,CAACD,GAAG,GAAG,CAAP,CAAd;AACD;;AACD,MAAI,CAACH,EAAL,EAAS;AACPA,IAAAA,EAAE,GAAG,GAAL;AACD,GA5B4B,CA6B7B;;;AACA,MAAI,EAAEA,EAAE,IAAI,IAAN,IAAcA,EAAE,IAAI,GAAtB,CAAJ,EAAgC;AAC9BA,IAAAA,EAAE,GAAGA,EAAE,CAACT,OAAH,CAAW,SAAX,EAAsB,EAAtB,CAAL;AACD;;AACD,SAAOS,EAAP;AAED,CAnCD,C,CAqCA;;;AACAnB,QAAQ,GAAG,UAAU+B,OAAV,EAAmB;AAC5B,MAAIC,GAAG,GAAGrC,IAAI,CAACsC,SAAL,CAAeF,OAAf,CAAV;AAAA,MACIG,KAAK,GAAG,EADZ;AAAA,MAEIC,GAAG,GAAG,CAACH,GAAD,CAFV;AAAA,MAGII,GAHJ;;AAKA,MAAI;AACFF,IAAAA,KAAK,GAAGzC,EAAE,CAAC4C,WAAH,CAAeL,GAAf,CAAR;AACD,GAFD,CAGA,OAAOM,CAAP,EAAU;AACRF,IAAAA,GAAG,GAAG,yBAAyBJ,GAAzB,GAA+B,IAArC;;AACA,QAAIM,CAAC,CAACC,KAAN,EAAa;AACXH,MAAAA,GAAG,IAAIE,CAAC,CAACC,KAAT;AACD;;AACD,UAAM,IAAIC,KAAJ,CAAUJ,GAAV,CAAN;AACD;;AAEDF,EAAAA,KAAK,CAACO,OAAN,CAAc,UAAUlB,CAAV,EAAa;AACzB,QAAImB,IAAI,GAAG/C,IAAI,CAACW,IAAL,CAAU0B,GAAV,EAAeT,CAAf,CAAX;AACA,QAAIoB,IAAI,GAAGlD,EAAE,CAACmD,QAAH,CAAYF,IAAZ,CAAX;;AACA,QAAIC,IAAI,CAACE,WAAL,EAAJ,EAAwB;AACtBV,MAAAA,GAAG,GAAGA,GAAG,CAACW,MAAJ,CAAW9C,QAAQ,CAAC0C,IAAD,CAAnB,CAAN;AACD,KAFD,MAGK;AACHP,MAAAA,GAAG,CAACY,IAAJ,CAASL,IAAT;AACD;AACF,GATD;AAWA,SAAOP,GAAP;AACD,CA7BD;AA+BA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACElC,QAAQ,GAAG,UAAU+B,GAAV,EAAegB,IAAf,EAAqB;AAC9B,MAAIC,OAAO,GAAGD,IAAI,IAAI,EAAtB;AAAA,MACIE,MAAM,GAAGD,OAAO,CAACC,MAAR,IAAkB,OAD/B;AAAA,MAEIf,GAFJ;AAGAA,EAAAA,GAAG,GAAGnC,QAAQ,CAACgC,GAAD,CAAd;AACA,SAAOkB,MAAM,IAAI,QAAV,GAAqBf,GAAG,CAAC7B,IAAJ,CAAS,IAAT,CAArB,GAAsC6B,GAA7C;AACD,CAND;;AASFjC,QAAQ,GAAG,UAAUiD,GAAV,EAAeH,IAAf,EAAqB;AAC9B,MAAII,OAAO,GAAGrD,OAAO,CAACoD,GAAD,CAArB;AAAA,MACIE,KADJ;AAAA,MAEIC,OAFJ;;AAIA,MAAI;AACFD,IAAAA,KAAK,GAAGpD,QAAQ,CAACmD,OAAD,CAAR,CAAkBG,GAAlB,CAAsB,UAASC,IAAT,EAAc;AAC1C,aAAOA,IAAI,CAAC9C,OAAL,CAAa,KAAb,EAAoB,GAApB,CAAP;AACD,KAFO,CAAR;AAGD,GAJD,CAKA;AACA,SAAM4B,CAAN,EAAS;AACPmB,IAAAA,OAAO,CAACC,KAAR,CAAcpB,CAAC,CAACqB,OAAhB;AACD;;AAED,MAAIN,KAAJ,EAAW;AACTF,IAAAA,GAAG,GAAGxD,IAAI,CAACsC,SAAL,CAAekB,GAAf,CAAN;AACAG,IAAAA,OAAO,GAAG1D,SAAS,CAACgE,KAAV,CAAgBP,KAAhB,EAAuBF,GAAvB,EAA4BH,IAAI,IAAI,EAApC,CAAV;AACD;;AACD,SAAOM,OAAO,IAAI,EAAlB;AACD,CApBD,C,CAsBA;AACA;AACA;;;AACA,IAAIO,aAAa,GAAGC,MAAM,CAACC,mBAAP,CAA2B9C,KAAK,CAAC+C,SAAjC,CAApB,CACA;AADA;AAAA,IAEIC,cAAc,GAAG;AACf,YAAU,IADK;AAEf,WAAS,IAFM;AAGf,YAAU,IAHK;AAIf,SAAO;AAJQ,CAFrB,CAQA;AARA;AAAA,IASIC,uBAAuB,GAAG,CACxB,yBADwB,EAExB,2BAFwB,EAGxB,2BAHwB,EAIxB,QAJwB,EAKxB,IALwB,CAT9B,CAgBA;AAhBA;AAAA,IAiBIC,oBAAoB,GAAG,CACrB,UAAUC,IAAV,EAAgB;AACd,MAAIC,KAAK,GAAG,KAAZ;AAAA,MACIC,KADJ;;AAEA,MAAI;AACFA,IAAAA,KAAK,GAAG7E,EAAE,CAACmD,QAAH,CAAYwB,IAAZ,CAAR;AACAC,IAAAA,KAAK,GAAGC,KAAK,CAACzB,WAAN,EAAR;AACD,GAHD,CAIA,OAAMP,CAAN,EAAS,CAAE;;AACX,SAAQ,iBAAD,CAAoBb,IAApB,CAAyB2C,IAAzB,KAAkC,CAACC,KAA1C;AACD,CAVoB,CAjB3B;;AA8BA,IAAIE,QAAQ,GAAG,YAAY;AACzB,MAAIC,IAAI,GAAG,IAAX;AAAA,MACIC,IADJ,CADyB,CAIzB;;AACA,OAAKC,UAAL,GAAkB,EAAlB,CALyB,CAMzB;;AACA,OAAKC,OAAL,GAAe,IAAf,CAPyB,CAQzB;;AACA,OAAKC,QAAL,GAAgB;AACdC,IAAAA,IAAI,EAAEX,uBAAuB,CAACxC,KAAxB,EADQ;AAEdoD,IAAAA,KAAK,EAAEX,oBAAoB,CAACzC,KAArB,EAFO;AAGdqD,IAAAA,KAAK,EAAE;AAHO,GAAhB;AAKA,OAAKC,KAAL,GAAa,EAAb,CAdyB,CAgBzB;;AACAP,EAAAA,IAAI,GAAG,UAAUQ,IAAV,EAAgB;AACrB,QAAIC,GAAJ;;AACAV,IAAAA,IAAI,CAACS,IAAD,CAAJ,GAAa,YAAY;AACvB,UAAIT,IAAI,CAACG,OAAT,EAAkB;AAChBH,QAAAA,IAAI,CAACW,OAAL;AACD;;AACD,UAAI,OAAOX,IAAI,CAACQ,KAAL,CAAWC,IAAX,CAAP,IAA2B,UAA/B,EAA2C;AACzC;AACA,YAAIhB,cAAc,CAACgB,IAAD,CAAlB,EAA0B;AACxBC,UAAAA,GAAG,GAAGV,IAAI,CAACQ,KAAL,CAAWC,IAAX,EAAiBG,KAAjB,CAAuBZ,IAAI,CAACQ,KAA5B,EAAmCK,SAAnC,CAAN;AACA,iBAAOd,QAAQ,CAACe,KAAT,CAAed,IAAf,EAAqBU,GAArB,CAAP;AACD,SAHD,MAIK;AACH,iBAAOV,IAAI,CAACQ,KAAL,CAAWC,IAAX,EAAiBG,KAAjB,CAAuBZ,IAAI,CAACQ,KAA5B,EAAmCK,SAAnC,CAAP;AACD;AACF,OATD,MAUK;AACH,eAAOb,IAAI,CAACQ,KAAL,CAAWC,IAAX,CAAP;AACD;AACF,KAjBD;AAkBD,GApBD;;AAqBA,OAAK,IAAIrD,CAAC,GAAG,CAAR,EAAW2D,EAAE,GAAG1B,aAAa,CAAC/B,MAAnC,EAA2CF,CAAC,GAAG2D,EAA/C,EAAmD3D,CAAC,EAApD,EAAwD;AACtD6C,IAAAA,IAAI,CAACZ,aAAa,CAACjC,CAAD,CAAd,CAAJ;AACD,GAxCwB,CA0CzB;;;AACA,OAAK4D,OAAL,CAAaJ,KAAb,CAAmB,IAAnB,EAAyBC,SAAzB,EA3CyB,CA6CzB;;AACA,OAAKI,WAAL,GAAmBlB,QAAnB;AACD,CA/CD;;KAAIA,Q;AAiDJA,QAAQ,CAACP,SAAT,GAAqB,IAAK,YAAY;AACpC,MAAI0B,WAAW,GAAG,UAAlB;;AAEA,MAAIC,YAAY,GAAG,UAAUC,IAAV,EAAgB;AAC7B,QAAItC,OAAO,GAAGpD,QAAQ,CAAC0F,IAAI,CAACjG,IAAN,EAAYiG,IAAI,CAAC3C,OAAjB,CAAtB;AACA,SAAK+B,KAAL,GAAa,KAAKA,KAAL,CAAWlC,MAAX,CAAkBQ,OAAlB,CAAb;AACD,GAHL;AAAA,MAKIuC,WAAW,GAAG,UAAUD,IAAV,EAAgB;AAC5B,QAAIF,WAAW,CAACjE,IAAZ,CAAiBmE,IAAI,CAACjG,IAAtB,CAAJ,EAAiC;AAC/BgG,MAAAA,YAAY,CAACG,IAAb,CAAkB,IAAlB,EAAwBF,IAAxB;AACD,KAFD,MAGK;AACH,WAAK7C,IAAL,CAAU6C,IAAI,CAACjG,IAAf;AACD;AACF,GAZL;AAAA,MAcIoG,mBAAmB,GAAG,YAAY;AAChC,QAAIlB,IAAI,GAAG,KAAKD,QAAL,CAAcC,IAAzB;AAAA,QACI1B,GADJ;AAAA,QAEI6C,IAAI,GAAG,EAFX;AAAA,QAGI1C,OAAO,GAAG,EAHd;;AAKA,SAAK,IAAI1B,CAAC,GAAG,CAAR,EAAW2D,EAAE,GAAGV,IAAI,CAAC/C,MAA1B,EAAkCF,CAAC,GAAG2D,EAAtC,EAA0C3D,CAAC,EAA3C,EAA+C;AAC7CuB,MAAAA,GAAG,GAAG0B,IAAI,CAACjD,CAAD,CAAV;;AACA,UAAI,OAAOuB,GAAP,IAAc,QAAlB,EAA4B;AAC1B;AACA,YAAI,OAAO1B,IAAP,CAAY0B,GAAZ,CAAJ,EAAsB;AACpBG,UAAAA,OAAO,GAAGpD,QAAQ,CAACiD,GAAD,CAAlB;AACAG,UAAAA,OAAO,GAAGA,OAAO,CAACC,GAAR,CAAY,UAAU0C,CAAV,EAAa;AACjC,mBAAOpG,iBAAiB,CAACoG,CAAD,CAAxB;AACD,WAFS,CAAV;AAGAD,UAAAA,IAAI,GAAGA,IAAI,CAAClD,MAAL,CAAYQ,OAAZ,CAAP;AACD,SAND,CAOA;AAPA,aAQK;AACH0C,YAAAA,IAAI,CAACjD,IAAL,CAAUlD,iBAAiB,CAACsD,GAAD,CAA3B;AACD;AACF,OAbD,CAcA;AAdA,WAeK,IAAIA,GAAG,YAAY9C,MAAnB,EAA2B;AAC9B2F,UAAAA,IAAI,CAACjD,IAAL,CAAUI,GAAG,CAAC+C,QAAJ,GAAexF,OAAf,CAAuB,UAAvB,EAAmC,EAAnC,CAAV;AACD;AACF;;AACD,QAAIsF,IAAI,CAAClE,MAAT,EAAiB;AACf,WAAK8C,QAAL,CAAcG,KAAd,GAAsB,IAAI1E,MAAJ,CAAW,MAAM2F,IAAI,CAAC1F,IAAL,CAAU,KAAV,CAAN,GAAyB,GAApC,CAAtB;AACD,KAFD,MAGK;AACH,WAAKsE,QAAL,CAAcG,KAAd,GAAsB,IAAtB;AACD;AACF,GA/CL;AAAA,MAiDIoB,eAAe,GAAG,YAAY;AAC5B,QAAI3B,IAAI,GAAG,IAAX;;AACAuB,IAAAA,mBAAmB,CAACD,IAApB,CAAyB,IAAzB,EAF4B,CAG5B;;;AACA,SAAKd,KAAL,GAAa,KAAKA,KAAL,CAAWoB,MAAX,CAAkB,UAAUhC,IAAV,EAAgB;AAC7C,aAAO,CAACI,IAAI,CAAC6B,aAAL,CAAmBjC,IAAnB,CAAR;AACD,KAFY,CAAb;AAGD,GAxDL;AA0DA;AACF;AACA;AACA;AACA;;;AACE,OAAKoB,OAAL,GAAe,YAAY;AACzB,QAAIc,IAAI,GAAGrF,KAAK,CAAC+C,SAAN,CAAgBtC,KAAhB,CAAsBoE,IAAtB,CAA2BT,SAA3B,CAAX;AAAA,QACMkB,GADN;AAAA,QAEMC,QAAQ,GAAG;AAAExB,MAAAA,KAAK,EAAE,EAAT;AAAa/B,MAAAA,OAAO,EAAE;AAAtB,KAFjB;;AAIA,SAAK,IAAIrB,CAAC,GAAG,CAAR,EAAW6E,IAAI,GAAGH,IAAI,CAACxE,MAA5B,EAAoCF,CAAC,GAAG6E,IAAxC,EAA8C7E,CAAC,EAA/C,EAAmD;AACjD2E,MAAAA,GAAG,GAAGD,IAAI,CAAC1E,CAAD,CAAV;;AAEA,UAAI,OAAO2E,GAAP,KAAe,QAAf,IAA2B,CAACtF,KAAK,CAACyF,OAAN,CAAcH,GAAd,CAAhC,EAAoD;AAClDzG,QAAAA,KAAK,CAAC0G,QAAQ,CAACvD,OAAV,EAAmBsD,GAAnB,CAAL;AACD,OAFD,MAEO;AACLC,QAAAA,QAAQ,CAACxB,KAAT,GAAiBwB,QAAQ,CAACxB,KAAT,CAAelC,MAAf,CAAsByD,GAAtB,EAA2BH,MAA3B,CAAkC,UAAUR,IAAV,EAAgB;AACjE,iBAAO,CAAC,CAACA,IAAT;AACD,SAFgB,CAAjB;AAGD;AACF;;AAED,QAAIZ,KAAK,GAAGwB,QAAQ,CAACxB,KAAT,CAAezB,GAAf,CAAmB,UAASqC,IAAT,EAAe;AAC5C,aAAO;AAAEjG,QAAAA,IAAI,EAAEiG,IAAR;AAAc3C,QAAAA,OAAO,EAAEuD,QAAQ,CAACvD;AAAhC,OAAP;AACD,KAFW,CAAZ;AAIA,SAAKyB,UAAL,GAAkB,KAAKA,UAAL,CAAgB5B,MAAhB,CAAuBkC,KAAvB,CAAlB;AAEA,WAAO,IAAP;AACD,GAxBD;AA0BA;AACF;AACA;AACA;AACA;AACA;;;AACE,OAAKqB,aAAL,GAAqB,UAAUjC,IAAV,EAAgB;AACnC,QAAI,CAAC,KAAKQ,QAAL,CAAcG,KAAnB,EAA0B;AACxBgB,MAAAA,mBAAmB,CAACD,IAApB,CAAyB,IAAzB;AACD;;AACD,QAAIE,IAAI,GAAG,KAAKpB,QAAhB;AACA,WAAOoB,IAAI,CAACjB,KAAL,CAAWtD,IAAX,CAAgB2C,IAAhB,KAAyB4B,IAAI,CAAClB,KAAL,CAAW6B,IAAX,CAAgB,UAAUC,CAAV,EAAa;AAC3D,aAAO,CAAC,CAACA,CAAC,CAACxC,IAAD,CAAV;AACD,KAF+B,CAAhC;AAGD,GARD;AAUA;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,OAAKyC,OAAL,GAAe,YAAY;AACzB,QAAIP,IAAI,GAAGrF,KAAK,CAACyF,OAAN,CAAcrB,SAAS,CAAC,CAAD,CAAvB,IAA8BA,SAAS,CAAC,CAAD,CAAvC,GAA6CA,SAAxD;AAAA,QACIkB,GADJ;;AAEA,SAAK,IAAI3E,CAAC,GAAG,CAAR,EAAW2D,EAAE,GAAGe,IAAI,CAACxE,MAA1B,EAAkCF,CAAC,GAAG2D,EAAtC,EAA0C3D,CAAC,EAA3C,EAA+C;AAC7C2E,MAAAA,GAAG,GAAGD,IAAI,CAAC1E,CAAD,CAAV;;AACA,UAAI,OAAO2E,GAAP,IAAc,UAAd,IAA4B,EAAEA,GAAG,YAAYlG,MAAjB,CAAhC,EAA0D;AACxD,aAAKuE,QAAL,CAAcE,KAAd,CAAoB/B,IAApB,CAAyBwD,GAAzB;AACD,OAFD,MAGK;AACH,aAAK3B,QAAL,CAAcC,IAAd,CAAmB9B,IAAnB,CAAwBwD,GAAxB;AACD;AACF;;AACD,QAAI,CAAC,KAAK5B,OAAV,EAAmB;AACjBwB,MAAAA,eAAe,CAACL,IAAhB,CAAqB,IAArB;AACD;;AACD,WAAO,IAAP;AACD,GAhBD;AAkBA;AACF;AACA;AACA;;;AACE,OAAKX,OAAL,GAAe,YAAY;AACzB,QAAIS,IAAJ;AAAA,QACIkB,UAAU,GAAG,UAAUvF,CAAV,EAAawF,CAAb,EAAgB;AAC3B,UAAIxF,CAAC,CAACC,OAAF,CAAUuF,CAAV,IAAe,CAAnB,EAAsB;AACpBxF,QAAAA,CAAC,CAACwB,IAAF,CAAOgE,CAAP;AACD;;AACD,aAAOxF,CAAP;AACD,KANL;;AAOA,QAAI,KAAKoD,OAAT,EAAkB;AAChB,WAAKA,OAAL,GAAe,KAAf;;AACA,aAAQiB,IAAI,GAAG,KAAKlB,UAAL,CAAgBsC,KAAhB,EAAf,EAAyC;AACvCnB,QAAAA,WAAW,CAACC,IAAZ,CAAiB,IAAjB,EAAuBF,IAAvB;AACD,OAJe,CAKhB;;;AACA,WAAKZ,KAAL,GAAa,KAAKA,KAAL,CAAWiC,MAAX,CAAkBH,UAAlB,EAA8B,EAA9B,CAAb,CANgB,CAOhB;;AACAX,MAAAA,eAAe,CAACL,IAAhB,CAAqB,IAArB;AACD;;AACD,WAAO,IAAP;AACD,GAnBD;AAqBA;AACF;AACA;;;AACE,OAAKoB,OAAL,GAAe,YAAY;AACzB;AACA,QAAI/E,GAAG,GAAG,KAAKT,KAAL,GAAasD,KAAb,CAAmBtD,KAAnB,EAAV;AACA,WAAOS,GAAP;AACD,GAJD;AAMA;AACF;AACA;AACA;;;AACE,OAAKgF,eAAL,GAAuB,YAAY;AACjC,SAAKzC,UAAL,GAAkB,EAAlB;AACA,WAAO,IAAP;AACD,GAHD;AAKA;AACF;AACA;;;AACE,OAAK0C,eAAL,GAAuB,YAAY;AACjC,SAAKxC,QAAL,GAAgB;AACdC,MAAAA,IAAI,EAAE,EADQ;AAEdC,MAAAA,KAAK,EAAE,EAFO;AAGdC,MAAAA,KAAK,EAAE;AAHO,KAAhB;AAKA,WAAO,IAAP;AACD,GAPD;AASD,CA5LoB,EAArB,C,CA8LA;AACA;;AACAR,QAAQ,CAACe,KAAT,GAAiB,UAAU+B,IAAV,EAAgBrC,KAAhB,EAAuB;AACtC,MAAIM,KAAK,GAAG,IAAIf,QAAJ,EAAZ;;AACA,MAAIS,KAAJ,EAAW;AACTM,IAAAA,KAAK,CAACN,KAAN,GAAcA,KAAd;AACD;;AACDM,EAAAA,KAAK,CAACZ,UAAN,GAAmB2C,IAAI,CAAC3C,UAAxB;AACAY,EAAAA,KAAK,CAACX,OAAN,GAAgB0C,IAAI,CAAC1C,OAArB;;AACA,OAAK,IAAIpD,CAAT,IAAc8F,IAAI,CAACzC,QAAnB,EAA6B;AAC3BU,IAAAA,KAAK,CAACV,QAAN,CAAerD,CAAf,IAAoB8F,IAAI,CAACzC,QAAL,CAAcrD,CAAd,CAApB;AACD;;AACD,SAAO+D,KAAP;AACD,CAXD;;AAaAgC,OAAO,CAAC/C,QAAR,GAAmBA,QAAnB","sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nvar fs = require('fs')\n, path = require('path')\n, minimatch = require('minimatch')\n, escapeRegExpChars\n, merge\n, basedir\n, _readDir\n, readdirR\n, globSync;\n\n  /**\n    @name escapeRegExpChars\n    @function\n    @return {String} A string of escaped characters\n    @description Escapes regex control-characters in strings\n                 used to build regexes dynamically\n    @param {String} string The string of chars to escape\n  */\n  escapeRegExpChars = (function () {\n    var specials = [ '^', '$', '/', '.', '*', '+', '?', '|', '(', ')',\n        '[', ']', '{', '}', '\\\\' ];\n    var sRE = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n    return function (string) {\n      var str = string || '';\n      str = String(str);\n      return str.replace(sRE, '\\\\$1');\n    };\n  })();\n\n  /**\n    @name merge\n    @function\n    @return {Object} Returns the merged object\n    @description Merge merges `otherObject` into `object` and takes care of deep\n                 merging of objects\n    @param {Object} object Object to merge into\n    @param {Object} otherObject Object to read from\n  */\n  merge = function (object, otherObject) {\n    var obj = object || {}\n      , otherObj = otherObject || {}\n      , key, value;\n\n    for (key in otherObj) {\n      value = otherObj[key];\n\n      // Check if a value is an Object, if so recursively add it's key/values\n      if (typeof value === 'object' && !(value instanceof Array)) {\n        // Update value of object to the one from otherObj\n        obj[key] = merge(obj[key], value);\n      }\n      // Value is anything other than an Object, so just add it\n      else {\n        obj[key] = value;\n      }\n    }\n\n    return obj;\n  };\n  /**\n    Given a patern, return the base directory of it (ie. the folder\n    that will contain all the files matching the path).\n    eg. file.basedir('/test/**') => '/test/'\n    Path ending by '/' are considerd as folder while other are considerd\n    as files, eg.:\n        file.basedir('/test/a/') => '/test/a'\n        file.basedir('/test/a') => '/test'\n    The returned path always end with a '/' so we have:\n        file.basedir(file.basedir(x)) == file.basedir(x)\n  */\n  basedir = function (pathParam) {\n    var bd = ''\n      , parts\n      , part\n      , pos = 0\n      , p = pathParam || '';\n\n    // If the path has a leading asterisk, basedir is the current dir\n    if (p.indexOf('*') == 0 || p.indexOf('**') == 0) {\n      return '.';\n    }\n\n    // always consider .. at the end as a folder and not a filename\n    if (/(?:^|\\/|\\\\)\\.\\.$/.test(p.slice(-3))) {\n      p += '/';\n    }\n\n    parts = p.split(/\\\\|\\//);\n    for (var i = 0, l = parts.length - 1; i < l; i++) {\n      part = parts[i];\n      if (part.indexOf('*') > -1 || part.indexOf('**') > -1) {\n        break;\n      }\n      pos += part.length + 1;\n      bd += part + p[pos - 1];\n    }\n    if (!bd) {\n      bd = '.';\n    }\n    // Strip trailing slashes\n    if (!(bd == '\\\\' || bd == '/')) {\n      bd = bd.replace(/\\\\$|\\/$/, '');\n    }\n    return bd;\n\n  };\n\n  // Return the contents of a given directory\n  _readDir = function (dirPath) {\n    var dir = path.normalize(dirPath)\n      , paths = []\n      , ret = [dir]\n      , msg;\n\n    try {\n      paths = fs.readdirSync(dir);\n    }\n    catch (e) {\n      msg = 'Could not read path ' + dir + '\\n';\n      if (e.stack) {\n        msg += e.stack;\n      }\n      throw new Error(msg);\n    }\n\n    paths.forEach(function (p) {\n      var curr = path.join(dir, p);\n      var stat = fs.statSync(curr);\n      if (stat.isDirectory()) {\n        ret = ret.concat(_readDir(curr));\n      }\n      else {\n        ret.push(curr);\n      }\n    });\n\n    return ret;\n  };\n\n  /**\n    @name file#readdirR\n    @function\n    @return {Array} Returns the contents as an Array, can be configured via opts.format\n    @description Reads the given directory returning it's contents\n    @param {String} dir The directory to read\n    @param {Object} opts Options to use\n      @param {String} [opts.format] Set the format to return(Default: Array)\n  */\n  readdirR = function (dir, opts) {\n    var options = opts || {}\n      , format = options.format || 'array'\n      , ret;\n    ret = _readDir(dir);\n    return format == 'string' ? ret.join('\\n') : ret;\n  };\n\n\nglobSync = function (pat, opts) {\n  var dirname = basedir(pat)\n    , files\n    , matches;\n\n  try {\n    files = readdirR(dirname).map(function(file){\n      return file.replace(/\\\\/g, '/');\n    });\n  }\n  // Bail if path doesn't exist -- assume no files\n  catch(e) {\n    console.error(e.message);\n  }\n\n  if (files) {\n    pat = path.normalize(pat);\n    matches = minimatch.match(files, pat, opts || {});\n  }\n  return matches || [];\n};\n\n// Constants\n// ---------------\n// List of all the builtin Array methods we want to override\nvar ARRAY_METHODS = Object.getOwnPropertyNames(Array.prototype)\n// Array methods that return a copy instead of affecting the original\n  , SPECIAL_RETURN = {\n      'concat': true\n    , 'slice': true\n    , 'filter': true\n    , 'map': true\n    }\n// Default file-patterns we want to ignore\n  , DEFAULT_IGNORE_PATTERNS = [\n      /(^|[\\/\\\\])CVS([\\/\\\\]|$)/\n    , /(^|[\\/\\\\])\\.svn([\\/\\\\]|$)/\n    , /(^|[\\/\\\\])\\.git([\\/\\\\]|$)/\n    , /\\.bak$/\n    , /~$/\n    ]\n// Ignore core files\n  , DEFAULT_IGNORE_FUNCS = [\n      function (name) {\n        var isDir = false\n          , stats;\n        try {\n          stats = fs.statSync(name);\n          isDir = stats.isDirectory();\n        }\n        catch(e) {}\n        return (/(^|[\\/\\\\])core$/).test(name) && !isDir;\n      }\n    ];\n\nvar FileList = function () {\n  var self = this\n    , wrap;\n\n  // List of glob-patterns or specific filenames\n  this.pendingAdd = [];\n  // Switched to false after lazy-eval of files\n  this.pending = true;\n  // Used to calculate exclusions from the list of files\n  this.excludes = {\n    pats: DEFAULT_IGNORE_PATTERNS.slice()\n  , funcs: DEFAULT_IGNORE_FUNCS.slice()\n  , regex: null\n  };\n  this.items = [];\n\n  // Wrap the array methods with the delegates\n  wrap = function (prop) {\n    var arr;\n    self[prop] = function () {\n      if (self.pending) {\n        self.resolve();\n      }\n      if (typeof self.items[prop] == 'function') {\n        // Special method that return a copy\n        if (SPECIAL_RETURN[prop]) {\n          arr = self.items[prop].apply(self.items, arguments);\n          return FileList.clone(self, arr);\n        }\n        else {\n          return self.items[prop].apply(self.items, arguments);\n        }\n      }\n      else {\n        return self.items[prop];\n      }\n    };\n  };\n  for (var i = 0, ii = ARRAY_METHODS.length; i < ii; i++) {\n    wrap(ARRAY_METHODS[i]);\n  }\n\n  // Include whatever files got passed to the constructor\n  this.include.apply(this, arguments);\n\n  // Fix constructor linkage\n  this.constructor = FileList;\n};\n\nFileList.prototype = new (function () {\n  var globPattern = /[*?\\[\\{]/;\n\n  var _addMatching = function (item) {\n        var matches = globSync(item.path, item.options);\n        this.items = this.items.concat(matches);\n      }\n\n    , _resolveAdd = function (item) {\n        if (globPattern.test(item.path)) {\n          _addMatching.call(this, item);\n        }\n        else {\n          this.push(item.path);\n        }\n      }\n\n    , _calculateExcludeRe = function () {\n        var pats = this.excludes.pats\n          , pat\n          , excl = []\n          , matches = [];\n\n        for (var i = 0, ii = pats.length; i < ii; i++) {\n          pat = pats[i];\n          if (typeof pat == 'string') {\n            // Glob, look up files\n            if (/[*?]/.test(pat)) {\n              matches = globSync(pat);\n              matches = matches.map(function (m) {\n                return escapeRegExpChars(m);\n              });\n              excl = excl.concat(matches);\n            }\n            // String for regex\n            else {\n              excl.push(escapeRegExpChars(pat));\n            }\n          }\n          // Regex, grab the string-representation\n          else if (pat instanceof RegExp) {\n            excl.push(pat.toString().replace(/^\\/|\\/$/g, ''));\n          }\n        }\n        if (excl.length) {\n          this.excludes.regex = new RegExp('(' + excl.join(')|(') + ')');\n        }\n        else {\n          this.excludes.regex = /^$/;\n        }\n      }\n\n    , _resolveExclude = function () {\n        var self = this;\n        _calculateExcludeRe.call(this);\n        // No `reject` method, so use reverse-filter\n        this.items = this.items.filter(function (name) {\n          return !self.shouldExclude(name);\n        });\n      };\n\n  /**\n   * Includes file-patterns in the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments should be strings\n   * for either a glob-pattern or a specific file-name, or an array of them\n   */\n  this.include = function () {\n    var args = Array.prototype.slice.call(arguments)\n        , arg\n        , includes = { items: [], options: {} };\n\n    for (var i = 0, ilen = args.length; i < ilen; i++) {\n      arg = args[i];\n\n      if (typeof arg === 'object' && !Array.isArray(arg)) {\n        merge(includes.options, arg);\n      } else {\n        includes.items = includes.items.concat(arg).filter(function (item) {\n          return !!item;\n        });\n      }\n    }\n\n    var items = includes.items.map(function(item) {\n      return { path: item, options: includes.options };\n    });\n\n    this.pendingAdd = this.pendingAdd.concat(items);\n\n    return this;\n  };\n\n  /**\n   * Indicates whether a particular file would be filtered out by the current\n   * exclusion rules for this FileList.\n   * @param {String} name The filename to check\n   * @return {Boolean} Whether or not the file should be excluded\n   */\n  this.shouldExclude = function (name) {\n    if (!this.excludes.regex) {\n      _calculateExcludeRe.call(this);\n    }\n    var excl = this.excludes;\n    return excl.regex.test(name) || excl.funcs.some(function (f) {\n      return !!f(name);\n    });\n  };\n\n  /**\n   * Excludes file-patterns from the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments can be:\n   * 1. Strings for either a glob-pattern or a specific file-name\n   * 2. Regular expression literals\n   * 3. Functions to be run on the filename that return a true/false\n   */\n  this.exclude = function () {\n    var args = Array.isArray(arguments[0]) ? arguments[0] : arguments\n      , arg;\n    for (var i = 0, ii = args.length; i < ii; i++) {\n      arg = args[i];\n      if (typeof arg == 'function' && !(arg instanceof RegExp)) {\n        this.excludes.funcs.push(arg);\n      }\n      else {\n        this.excludes.pats.push(arg);\n      }\n    }\n    if (!this.pending) {\n      _resolveExclude.call(this);\n    }\n    return this;\n  };\n\n  /**\n   * Populates the FileList from the include/exclude rules with a list of\n   * actual files\n   */\n  this.resolve = function () {\n    var item\n      , uniqueFunc = function (p, c) {\n          if (p.indexOf(c) < 0) {\n            p.push(c);\n          }\n          return p;\n        };\n    if (this.pending) {\n      this.pending = false;\n      while ((item = this.pendingAdd.shift())) {\n        _resolveAdd.call(this, item);\n      }\n      // Reduce to a unique list\n      this.items = this.items.reduce(uniqueFunc, []);\n      // Remove exclusions\n      _resolveExclude.call(this);\n    }\n    return this;\n  };\n\n  /**\n   * Convert to a plain-jane array\n   */\n  this.toArray = function () {\n    // Call slice to ensure lazy-resolution before slicing items\n    var ret = this.slice().items.slice();\n    return ret;\n  };\n\n  /**\n   * Clear any pending items -- only useful before\n   * calling `resolve`\n   */\n  this.clearInclusions = function () {\n    this.pendingAdd = [];\n    return this;\n  };\n\n  /**\n   * Clear any current exclusion rules\n   */\n  this.clearExclusions = function () {\n    this.excludes = {\n      pats: []\n    , funcs: []\n    , regex: null\n    };\n    return this;\n  };\n\n})();\n\n// Static method, used to create copy returned by special\n// array methods\nFileList.clone = function (list, items) {\n  var clone = new FileList();\n  if (items) {\n    clone.items = items;\n  }\n  clone.pendingAdd = list.pendingAdd;\n  clone.pending = list.pending;\n  for (var p in list.excludes) {\n    clone.excludes[p] = list.excludes[p];\n  }\n  return clone;\n};\n\nexports.FileList = FileList;\n"]},"metadata":{},"sourceType":"module"}