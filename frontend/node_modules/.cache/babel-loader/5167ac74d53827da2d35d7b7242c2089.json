{"ast":null,"code":"","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["declare module \"ipaddr.js\" {\n    type IPv4Range = 'unicast' | 'unspecified' | 'broadcast' | 'multicast' | 'linkLocal' | 'loopback' | 'carrierGradeNat' | 'private' | 'reserved';\n    type IPv6Range = 'unicast' | 'unspecified' | 'linkLocal' | 'multicast' | 'loopback' | 'uniqueLocal' | 'ipv4Mapped' | 'rfc6145' | 'rfc6052' | '6to4' | 'teredo' | 'reserved';\n\n    interface RangeList<T> {\n        [name: string]: [T, number] | [T, number][];\n    }\n\n    // Common methods/properties for IPv4 and IPv6 classes.\n    class IP {\n        prefixLengthFromSubnetMask(): number | null;\n        toByteArray(): number[];\n        toNormalizedString(): string;\n        toString(): string;\n    }\n\n    namespace Address {\n        export function isValid(addr: string): boolean;\n        export function fromByteArray(bytes: number[]): IPv4 | IPv6;\n        export function parse(addr: string): IPv4 | IPv6;\n        export function parseCIDR(mask: string): [IPv4 | IPv6, number];\n        export function process(addr: string): IPv4 | IPv6;\n        export function subnetMatch(addr: IPv4, rangeList: RangeList<IPv4>, defaultName?: string): string;\n        export function subnetMatch(addr: IPv6, rangeList: RangeList<IPv6>, defaultName?: string): string;\n\n        export class IPv4 extends IP {\n            static broadcastAddressFromCIDR(addr: string): IPv4;\n            static isIPv4(addr: string): boolean;\n            static isValidFourPartDecimal(addr: string): boolean;\n            static isValid(addr: string): boolean;\n            static networkAddressFromCIDR(addr: string): IPv4;\n            static parse(addr: string): IPv4;\n            static parseCIDR(addr: string): [IPv4, number];\n            static subnetMaskFromPrefixLength(prefix: number): IPv4;\n            constructor(octets: number[]);\n            octets: number[]\n\n            kind(): 'ipv4';\n            match(addr: IPv4, bits: number): boolean;\n            match(mask: [IPv4, number]): boolean;\n            range(): IPv4Range;\n            subnetMatch(rangeList: RangeList<IPv4>, defaultName?: string): string;\n            toIPv4MappedAddress(): IPv6;\n        }\n\n        export class IPv6 extends IP {\n            static broadcastAddressFromCIDR(addr: string): IPv6;\n            static isIPv6(addr: string): boolean;\n            static isValid(addr: string): boolean;\n            static parse(addr: string): IPv6;\n            static parseCIDR(addr: string): [IPv6, number];\n            static subnetMaskFromPrefixLength(prefix: number): IPv6;\n            constructor(parts: number[]);\n            parts: number[]\n            zoneId?: string\n\n            isIPv4MappedAddress(): boolean;\n            kind(): 'ipv6';\n            match(addr: IPv6, bits: number): boolean;\n            match(mask: [IPv6, number]): boolean;\n            range(): IPv6Range;\n            subnetMatch(rangeList: RangeList<IPv6>, defaultName?: string): string;\n            toIPv4Address(): IPv4;\n        }\n    }\n\n    export = Address;\n}\n"]},"metadata":{},"sourceType":"module"}