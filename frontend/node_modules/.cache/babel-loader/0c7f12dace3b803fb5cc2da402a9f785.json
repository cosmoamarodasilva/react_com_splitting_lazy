{"ast":null,"code":"let path = require('path');\n\nlet fs = require('fs');\n\nlet Task = require('./task/task').Task; // Split a task to two parts, name space and task name.\n// For example, given 'foo:bin/a%.c', return an object with\n// - 'ns'     : foo\n// - 'name'   : bin/a%.c\n\n\nfunction splitNs(task) {\n  let parts = task.split(':');\n  let name = parts.pop();\n  let ns = resolveNs(parts);\n  return {\n    'name': name,\n    'ns': ns\n  };\n} // Return the namespace based on an array of names.\n// For example, given ['foo', 'baz' ], return the namespace\n//\n//   default -> foo -> baz\n//\n// where default is the global root namespace\n// and -> means child namespace.\n\n\nfunction resolveNs(parts) {\n  let ns = jake.defaultNamespace;\n\n  for (let i = 0, l = parts.length; ns && i < l; i++) {\n    ns = ns.childNamespaces[parts[i]];\n  }\n\n  return ns;\n} // Given a pattern p, say 'foo:bin/a%.c'\n// Return an object with\n// - 'ns'     : foo\n// - 'dir'    : bin\n// - 'prefix' : a\n// - 'suffix' : .c\n\n\nfunction resolve(p) {\n  let task = splitNs(p);\n  let name = task.name;\n  let ns = task.ns;\n  let split = path.basename(name).split('%');\n  return {\n    ns: ns,\n    dir: path.dirname(name),\n    prefix: split[0],\n    suffix: split[1]\n  };\n} // Test whether string a is a suffix of string b\n\n\nfunction stringEndWith(a, b) {\n  let l;\n  return (l = b.lastIndexOf(a)) == -1 ? false : l + a.length == b.length;\n} // Replace the suffix a of the string s with b.\n// Note that, it is assumed a is a suffix of s.\n\n\nfunction stringReplaceSuffix(s, a, b) {\n  return s.slice(0, s.lastIndexOf(a)) + b;\n}\n\nclass Rule {\n  constructor(opts) {\n    this.pattern = opts.pattern;\n    this.source = opts.source;\n    this.prereqs = opts.prereqs;\n    this.action = opts.action;\n    this.opts = opts.opts;\n    this.desc = opts.desc;\n    this.ns = opts.ns;\n  } // Create a file task based on this rule for the specified\n  // task-name\n  // ======\n  // FIXME: Right now this just throws away any passed-in args\n  // for the synthsized task (taskArgs param)\n  // ======\n\n\n  createTask(fullName, level) {\n    let self = this;\n    let pattern;\n    let source;\n    let action;\n    let opts;\n    let prereqs;\n    let valid;\n    let src;\n    let tNs;\n    let createdTask;\n    let name = Task.getBaseTaskName(fullName);\n    let nsPath = Task.getBaseNamespacePath(fullName);\n    let ns = this.ns.resolveNamespace(nsPath);\n    pattern = this.pattern;\n    source = this.source;\n\n    if (typeof source == 'string') {\n      src = Rule.getSource(name, pattern, source);\n    } else {\n      src = source(name);\n    } // TODO: Write a utility function that appends a\n    // taskname to a namespace path\n\n\n    src = nsPath.split(':').filter(function (item) {\n      return !!item;\n    }).concat(src).join(':'); // Generate the prerequisite for the matching task.\n    //    It is the original prerequisites plus the prerequisite\n    //    representing source file, i.e.,\n    //\n    //      rule( '%.o', '%.c', ['some.h'] ...\n    //\n    //    If the objective is main.o, then new task should be\n    //\n    //      file( 'main.o', ['main.c', 'some.h' ] ...\n\n    prereqs = this.prereqs.slice(); // Get a copy to work with\n\n    prereqs.unshift(src); // Prereq should be:\n    // 1. an existing task\n    // 2. an existing file on disk\n    // 3. a valid rule (i.e., not at too deep a level)\n\n    valid = prereqs.some(function (p) {\n      let ns = self.ns;\n      return ns.resolveTask(p) || fs.existsSync(Task.getBaseTaskName(p)) || jake.attemptRule(p, ns, level + 1);\n    }); // If any of the prereqs aren't valid, the rule isn't valid\n\n    if (!valid) {\n      return null;\n    } // Otherwise, hunky-dory, finish creating the task for the rule\n    else {\n        // Create the action for the task\n        action = function () {\n          let task = this;\n          self.action.apply(task);\n        };\n\n        opts = this.opts; // Insert the file task into Jake\n        //\n        // Since createTask function stores the task as a child task\n        // of currentNamespace. Here we temporariliy switch the namespace.\n        // FIXME: Should allow optional ns passed in instead of this hack\n\n        tNs = jake.currentNamespace;\n        jake.currentNamespace = ns;\n        createdTask = jake.createTask('file', name, prereqs, action, opts);\n        createdTask.source = src.split(':').pop();\n        jake.currentNamespace = tNs;\n        return createdTask;\n      }\n  }\n\n  match(name) {\n    return Rule.match(this.pattern, name);\n  } // Test wether the a prerequisite matchs the pattern.\n  // The arg 'pattern' does not have namespace as prefix.\n  // For example, the following tests are true\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    bin/main.o\n  //   bin/%.o      |    foo:bin/main.o\n  //\n  // The following tests are false (trivally)\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    foobin/main.o\n  //   bin/%.o      |    bin/main.oo\n\n\n  static match(pattern, name) {\n    let p;\n    let task;\n    let obj;\n    let filename;\n\n    if (pattern instanceof RegExp) {\n      return pattern.test(name);\n    } else if (pattern.indexOf('%') == -1) {\n      // No Pattern. No Folder. No Namespace.\n      // A Simple Suffix Rule. Just test suffix\n      return stringEndWith(pattern, name);\n    } else {\n      // Resolve the dir, prefix and suffix of pattern\n      p = resolve(pattern); // Resolve the namespace and task-name\n\n      task = splitNs(name);\n      name = task.name; // Set the objective as the task-name\n\n      obj = name; // Namespace is already matched.\n      // Check dir\n\n      if (path.dirname(obj) != p.dir) {\n        return false;\n      }\n\n      filename = path.basename(obj); // Check file name length\n\n      if (p.prefix.length + p.suffix.length + 1 > filename.length) {\n        // Length does not match.\n        return false;\n      } // Check prefix\n\n\n      if (filename.indexOf(p.prefix) !== 0) {\n        return false;\n      } // Check suffix\n\n\n      if (!stringEndWith(p.suffix, filename)) {\n        return false;\n      } // OK. Find a match.\n\n\n      return true;\n    }\n  } // Generate the source based on\n  //  - name    name for the synthesized task\n  //  - pattern    pattern for the objective\n  //  - source    pattern for the source\n  //\n  // Return the source with properties\n  //  - dep      the prerequisite of source\n  //             (with the namespace)\n  //\n  //  - file     the file name of source\n  //             (without the namespace)\n  //\n  // For example, given\n  //\n  //  - name   foo:bin/main.o\n  //  - pattern    bin/%.o\n  //  - source    src/%.c\n  //\n  //    return 'foo:src/main.c',\n  //\n\n\n  static getSource(name, pattern, source) {\n    let dep;\n    let pat;\n    let match;\n    let file;\n    let src; // Regex pattern -- use to look up the extension\n\n    if (pattern instanceof RegExp) {\n      match = pattern.exec(name);\n\n      if (match) {\n        if (typeof source == 'function') {\n          src = source(name);\n        } else {\n          src = stringReplaceSuffix(name, match[0], source);\n        }\n      }\n    } // Assume string\n    else {\n        // Simple string suffix replacement\n        if (pattern.indexOf('%') == -1) {\n          if (typeof source == 'function') {\n            src = source(name);\n          } else {\n            src = stringReplaceSuffix(name, pattern, source);\n          }\n        } // Percent-based substitution\n        else {\n            pat = pattern.replace('%', '(.*?)');\n            pat = new RegExp(pat);\n            match = pat.exec(name);\n\n            if (match) {\n              if (typeof source == 'function') {\n                src = source(name);\n              } else {\n                file = match[1];\n                file = source.replace('%', file);\n                dep = match[0];\n                src = name.replace(dep, file);\n              }\n            }\n          }\n      }\n\n    return src;\n  }\n\n}\n\nexports.Rule = Rule;","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/rule.js"],"names":["path","require","fs","Task","splitNs","task","parts","split","name","pop","ns","resolveNs","jake","defaultNamespace","i","l","length","childNamespaces","resolve","p","basename","dir","dirname","prefix","suffix","stringEndWith","a","b","lastIndexOf","stringReplaceSuffix","s","slice","Rule","constructor","opts","pattern","source","prereqs","action","desc","createTask","fullName","level","self","valid","src","tNs","createdTask","getBaseTaskName","nsPath","getBaseNamespacePath","resolveNamespace","getSource","filter","item","concat","join","unshift","some","resolveTask","existsSync","attemptRule","apply","currentNamespace","match","obj","filename","RegExp","test","indexOf","dep","pat","file","exec","replace","exports"],"mappings":"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","sourcesContent":["let path = require('path');\nlet fs = require('fs');\nlet Task = require('./task/task').Task;\n\n// Split a task to two parts, name space and task name.\n// For example, given 'foo:bin/a%.c', return an object with\n// - 'ns'     : foo\n// - 'name'   : bin/a%.c\nfunction splitNs(task) {\n  let parts = task.split(':');\n  let name = parts.pop();\n  let ns = resolveNs(parts);\n  return {\n    'name' : name,\n    'ns'   : ns\n  };\n}\n\n// Return the namespace based on an array of names.\n// For example, given ['foo', 'baz' ], return the namespace\n//\n//   default -> foo -> baz\n//\n// where default is the global root namespace\n// and -> means child namespace.\nfunction resolveNs(parts) {\n  let  ns = jake.defaultNamespace;\n  for(let i = 0, l = parts.length; ns && i < l; i++) {\n    ns = ns.childNamespaces[parts[i]];\n  }\n  return ns;\n}\n\n// Given a pattern p, say 'foo:bin/a%.c'\n// Return an object with\n// - 'ns'     : foo\n// - 'dir'    : bin\n// - 'prefix' : a\n// - 'suffix' : .c\nfunction resolve(p) {\n  let task = splitNs(p);\n  let name  = task.name;\n  let ns    = task.ns;\n  let split = path.basename(name).split('%');\n  return {\n    ns: ns,\n    dir: path.dirname(name),\n    prefix: split[0],\n    suffix: split[1]\n  };\n}\n\n// Test whether string a is a suffix of string b\nfunction stringEndWith(a, b) {\n  let l;\n  return (l = b.lastIndexOf(a)) == -1 ? false : l + a.length == b.length;\n}\n\n// Replace the suffix a of the string s with b.\n// Note that, it is assumed a is a suffix of s.\nfunction stringReplaceSuffix(s, a, b) {\n  return s.slice(0, s.lastIndexOf(a)) + b;\n}\n\nclass Rule {\n  constructor(opts) {\n    this.pattern = opts.pattern;\n    this.source = opts.source;\n    this.prereqs = opts.prereqs;\n    this.action = opts.action;\n    this.opts = opts.opts;\n    this.desc =  opts.desc;\n    this.ns = opts.ns;\n  }\n\n  // Create a file task based on this rule for the specified\n  // task-name\n  // ======\n  // FIXME: Right now this just throws away any passed-in args\n  // for the synthsized task (taskArgs param)\n  // ======\n  createTask(fullName, level) {\n    let self = this;\n    let pattern;\n    let source;\n    let action;\n    let opts;\n    let prereqs;\n    let valid;\n    let src;\n    let tNs;\n    let createdTask;\n    let name = Task.getBaseTaskName(fullName);\n    let nsPath = Task.getBaseNamespacePath(fullName);\n    let ns = this.ns.resolveNamespace(nsPath);\n\n    pattern = this.pattern;\n    source = this.source;\n\n    if (typeof source == 'string') {\n      src = Rule.getSource(name, pattern, source);\n    }\n    else {\n      src = source(name);\n    }\n\n    // TODO: Write a utility function that appends a\n    // taskname to a namespace path\n    src = nsPath.split(':').filter(function (item) {\n      return !!item;\n    }).concat(src).join(':');\n\n    // Generate the prerequisite for the matching task.\n    //    It is the original prerequisites plus the prerequisite\n    //    representing source file, i.e.,\n    //\n    //      rule( '%.o', '%.c', ['some.h'] ...\n    //\n    //    If the objective is main.o, then new task should be\n    //\n    //      file( 'main.o', ['main.c', 'some.h' ] ...\n    prereqs = this.prereqs.slice(); // Get a copy to work with\n    prereqs.unshift(src);\n\n    // Prereq should be:\n    // 1. an existing task\n    // 2. an existing file on disk\n    // 3. a valid rule (i.e., not at too deep a level)\n    valid = prereqs.some(function (p) {\n      let ns = self.ns;\n      return ns.resolveTask(p) ||\n        fs.existsSync(Task.getBaseTaskName(p)) ||\n        jake.attemptRule(p, ns, level + 1);\n    });\n\n    // If any of the prereqs aren't valid, the rule isn't valid\n    if (!valid) {\n      return null;\n    }\n    // Otherwise, hunky-dory, finish creating the task for the rule\n    else {\n      // Create the action for the task\n      action = function () {\n        let task = this;\n        self.action.apply(task);\n      };\n\n      opts = this.opts;\n\n      // Insert the file task into Jake\n      //\n      // Since createTask function stores the task as a child task\n      // of currentNamespace. Here we temporariliy switch the namespace.\n      // FIXME: Should allow optional ns passed in instead of this hack\n      tNs = jake.currentNamespace;\n      jake.currentNamespace = ns;\n      createdTask = jake.createTask('file', name, prereqs, action, opts);\n      createdTask.source = src.split(':').pop();\n      jake.currentNamespace = tNs;\n\n      return createdTask;\n    }\n  }\n\n  match(name) {\n    return Rule.match(this.pattern, name);\n  }\n\n  // Test wether the a prerequisite matchs the pattern.\n  // The arg 'pattern' does not have namespace as prefix.\n  // For example, the following tests are true\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    bin/main.o\n  //   bin/%.o      |    foo:bin/main.o\n  //\n  // The following tests are false (trivally)\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    foobin/main.o\n  //   bin/%.o      |    bin/main.oo\n  static match(pattern, name) {\n    let p;\n    let task;\n    let obj;\n    let filename;\n\n    if (pattern instanceof RegExp) {\n      return pattern.test(name);\n    }\n    else if (pattern.indexOf('%') == -1) {\n      // No Pattern. No Folder. No Namespace.\n      // A Simple Suffix Rule. Just test suffix\n      return stringEndWith(pattern, name);\n    }\n    else {\n      // Resolve the dir, prefix and suffix of pattern\n      p = resolve(pattern);\n\n      // Resolve the namespace and task-name\n      task = splitNs(name);\n      name = task.name;\n\n      // Set the objective as the task-name\n      obj = name;\n\n      // Namespace is already matched.\n\n      // Check dir\n      if (path.dirname(obj) != p.dir) {\n        return false;\n      }\n\n      filename = path.basename(obj);\n\n      // Check file name length\n      if ((p.prefix.length + p.suffix.length + 1) > filename.length) {\n        // Length does not match.\n        return false;\n      }\n\n      // Check prefix\n      if (filename.indexOf(p.prefix) !== 0) {\n        return false;\n      }\n\n      // Check suffix\n      if (!stringEndWith(p.suffix, filename)) {\n        return false;\n      }\n\n      // OK. Find a match.\n      return true;\n    }\n  }\n\n  // Generate the source based on\n  //  - name    name for the synthesized task\n  //  - pattern    pattern for the objective\n  //  - source    pattern for the source\n  //\n  // Return the source with properties\n  //  - dep      the prerequisite of source\n  //             (with the namespace)\n  //\n  //  - file     the file name of source\n  //             (without the namespace)\n  //\n  // For example, given\n  //\n  //  - name   foo:bin/main.o\n  //  - pattern    bin/%.o\n  //  - source    src/%.c\n  //\n  //    return 'foo:src/main.c',\n  //\n  static getSource(name, pattern, source) {\n    let dep;\n    let pat;\n    let match;\n    let file;\n    let src;\n\n    // Regex pattern -- use to look up the extension\n    if (pattern instanceof RegExp) {\n      match = pattern.exec(name);\n      if (match) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = stringReplaceSuffix(name, match[0], source);\n        }\n      }\n    }\n    // Assume string\n    else {\n      // Simple string suffix replacement\n      if (pattern.indexOf('%') == -1) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = stringReplaceSuffix(name, pattern, source);\n        }\n      }\n      // Percent-based substitution\n      else {\n        pat = pattern.replace('%', '(.*?)');\n        pat = new RegExp(pat);\n        match = pat.exec(name);\n        if (match) {\n          if (typeof source == 'function') {\n            src = source(name);\n          }\n          else {\n            file = match[1];\n            file = source.replace('%', file);\n            dep = match[0];\n            src = name.replace(dep, file);\n          }\n        }\n      }\n    }\n\n    return src;\n  }\n}\n\n\nexports.Rule = Rule;\n"]},"metadata":{},"sourceType":"module"}