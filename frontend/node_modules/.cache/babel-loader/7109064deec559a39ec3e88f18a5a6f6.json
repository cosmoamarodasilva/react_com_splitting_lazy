{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet parseargs = {};\n\nlet isOpt = function (arg) {\n  return arg.indexOf('-') === 0;\n};\n\nlet removeOptPrefix = function (opt) {\n  return opt.replace(/^--/, '').replace(/^-/, '');\n};\n/**\n * @constructor\n * Parses a list of command-line args into a key/value object of\n * options and an array of positional commands.\n * @ param {Array} opts A list of options in the following format:\n * [{full: 'foo', abbr: 'f'}, {full: 'bar', abbr: 'b'}]]\n */\n\n\nparseargs.Parser = function (opts) {\n  // A key/value object of matching options parsed out of the args\n  this.opts = {};\n  this.taskNames = null;\n  this.envVars = null; // Data structures used for parsing\n\n  this.reg = opts;\n  this.shortOpts = {};\n  this.longOpts = {};\n  let self = this;\n  [].forEach.call(opts, function (item) {\n    self.shortOpts[item.abbr] = item;\n    self.longOpts[item.full] = item;\n  });\n};\n\nparseargs.Parser.prototype = new function () {\n  let _trueOrNextVal = function (argParts, args) {\n    if (argParts[1]) {\n      return argParts[1];\n    } else {\n      return !args[0] || isOpt(args[0]) ? true : args.shift();\n    }\n  };\n  /**\n   * Parses an array of arguments into options and positional commands\n   * @param {Array} args The command-line args to parse\n   */\n\n\n  this.parse = function (args) {\n    let cmds = [];\n    let cmd;\n    let envVars = {};\n    let opts = {};\n    let arg;\n    let argItem;\n    let argParts;\n    let cmdItems;\n    let taskNames = [];\n    let preempt;\n\n    while (args.length) {\n      arg = args.shift();\n\n      if (isOpt(arg)) {\n        arg = removeOptPrefix(arg);\n        argParts = arg.split('=');\n        argItem = this.longOpts[argParts[0]] || this.shortOpts[argParts[0]];\n\n        if (argItem) {\n          // First-encountered preemptive opt takes precedence -- no further opts\n          // or possibility of ambiguity, so just look for a value, or set to\n          // true and then bail\n          if (argItem.preempts) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            preempt = true;\n            break;\n          } // If the opt requires a value, see if we can get a value from the\n          // next arg, or infer true from no-arg -- if it's followed by another\n          // opt, throw an error\n\n\n          if (argItem.expectValue || argItem.allowValue) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n\n            if (argItem.expectValue && !opts[argItem.full]) {\n              throw new Error(argItem.full + ' option expects a value.');\n            }\n          } else {\n            opts[argItem.full] = true;\n          }\n        }\n      } else {\n        cmds.unshift(arg);\n      }\n    }\n\n    if (!preempt) {\n      // Parse out any env-vars and task-name\n      while (cmd = cmds.pop()) {\n        cmdItems = cmd.split('=');\n\n        if (cmdItems.length > 1) {\n          envVars[cmdItems[0]] = cmdItems[1];\n        } else {\n          taskNames.push(cmd);\n        }\n      }\n    }\n\n    return {\n      opts: opts,\n      envVars: envVars,\n      taskNames: taskNames\n    };\n  };\n}();\nmodule.exports = parseargs;","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/jake/lib/parseargs.js"],"names":["parseargs","isOpt","arg","indexOf","removeOptPrefix","opt","replace","Parser","opts","taskNames","envVars","reg","shortOpts","longOpts","self","forEach","call","item","abbr","full","prototype","_trueOrNextVal","argParts","args","shift","parse","cmds","cmd","argItem","cmdItems","preempt","length","split","preempts","expectValue","allowValue","Error","unshift","pop","push","module","exports"],"mappings":"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","sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet parseargs = {};\nlet isOpt = function (arg) { return arg.indexOf('-') === 0 };\nlet removeOptPrefix = function (opt) { return opt.replace(/^--/, '').replace(/^-/, '') };\n\n/**\n * @constructor\n * Parses a list of command-line args into a key/value object of\n * options and an array of positional commands.\n * @ param {Array} opts A list of options in the following format:\n * [{full: 'foo', abbr: 'f'}, {full: 'bar', abbr: 'b'}]]\n */\nparseargs.Parser = function (opts) {\n  // A key/value object of matching options parsed out of the args\n  this.opts = {};\n  this.taskNames = null;\n  this.envVars = null;\n\n  // Data structures used for parsing\n  this.reg = opts;\n  this.shortOpts = {};\n  this.longOpts = {};\n\n  let self = this;\n  [].forEach.call(opts, function (item) {\n    self.shortOpts[item.abbr] = item;\n    self.longOpts[item.full] = item;\n  });\n};\n\nparseargs.Parser.prototype = new function () {\n\n  let _trueOrNextVal = function (argParts, args) {\n    if (argParts[1]) {\n      return argParts[1];\n    }\n    else {\n      return (!args[0] || isOpt(args[0])) ?\n        true : args.shift();\n    }\n  };\n\n  /**\n   * Parses an array of arguments into options and positional commands\n   * @param {Array} args The command-line args to parse\n   */\n  this.parse = function (args) {\n    let cmds = [];\n    let cmd;\n    let envVars = {};\n    let opts = {};\n    let arg;\n    let argItem;\n    let argParts;\n    let cmdItems;\n    let taskNames = [];\n    let preempt;\n\n    while (args.length) {\n      arg = args.shift();\n\n      if (isOpt(arg)) {\n        arg = removeOptPrefix(arg);\n        argParts = arg.split('=');\n        argItem = this.longOpts[argParts[0]] || this.shortOpts[argParts[0]];\n        if (argItem) {\n          // First-encountered preemptive opt takes precedence -- no further opts\n          // or possibility of ambiguity, so just look for a value, or set to\n          // true and then bail\n          if (argItem.preempts) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            preempt = true;\n            break;\n          }\n          // If the opt requires a value, see if we can get a value from the\n          // next arg, or infer true from no-arg -- if it's followed by another\n          // opt, throw an error\n          if (argItem.expectValue || argItem.allowValue) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            if (argItem.expectValue && !opts[argItem.full]) {\n              throw new Error(argItem.full + ' option expects a value.');\n            }\n          }\n          else {\n            opts[argItem.full] = true;\n          }\n        }\n      }\n      else {\n        cmds.unshift(arg);\n      }\n    }\n\n    if (!preempt) {\n      // Parse out any env-vars and task-name\n      while ((cmd = cmds.pop())) {\n        cmdItems = cmd.split('=');\n        if (cmdItems.length > 1) {\n          envVars[cmdItems[0]] = cmdItems[1];\n        }\n        else {\n          taskNames.push(cmd);\n        }\n      }\n\n    }\n\n    return {\n      opts: opts,\n      envVars: envVars,\n      taskNames: taskNames\n    };\n  };\n\n};\n\nmodule.exports = parseargs;\n"]},"metadata":{},"sourceType":"module"}