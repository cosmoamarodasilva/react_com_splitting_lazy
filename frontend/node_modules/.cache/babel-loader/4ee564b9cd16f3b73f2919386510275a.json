{"ast":null,"code":"'use strict';\n\nconst stringWidth = require('string-width');\n\nconst chalk = require('chalk');\n\nconst widestLine = require('widest-line');\n\nconst cliBoxes = require('cli-boxes');\n\nconst camelCase = require('camelcase');\n\nconst ansiAlign = require('ansi-align');\n\nconst termSize = require('term-size');\n\nconst getObject = detail => {\n  let object;\n\n  if (typeof detail === 'number') {\n    object = {\n      top: detail,\n      right: detail * 3,\n      bottom: detail,\n      left: detail * 3\n    };\n  } else {\n    object = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...detail\n    };\n  }\n\n  return object;\n};\n\nconst getBorderChars = borderStyle => {\n  const sides = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft', 'vertical', 'horizontal'];\n  let chararacters;\n\n  if (typeof borderStyle === 'string') {\n    chararacters = cliBoxes[borderStyle];\n\n    if (!chararacters) {\n      throw new TypeError(`Invalid border style: ${borderStyle}`);\n    }\n  } else {\n    for (const side of sides) {\n      if (!borderStyle[side] || typeof borderStyle[side] !== 'string') {\n        throw new TypeError(`Invalid border style: ${side}`);\n      }\n    }\n\n    chararacters = borderStyle;\n  }\n\n  return chararacters;\n};\n\nconst isHex = color => color.match(/^#[0-f]{3}(?:[0-f]{3})?$/i);\n\nconst isColorValid = color => typeof color === 'string' && (chalk[color] || isHex(color));\n\nconst getColorFn = color => isHex(color) ? chalk.hex(color) : chalk[color];\n\nconst getBGColorFn = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];\n\nmodule.exports = (text, options) => {\n  options = {\n    padding: 0,\n    borderStyle: 'single',\n    dimBorder: false,\n    align: 'left',\n    float: 'left',\n    ...options\n  };\n\n  if (options.borderColor && !isColorValid(options.borderColor)) {\n    throw new Error(`${options.borderColor} is not a valid borderColor`);\n  }\n\n  if (options.backgroundColor && !isColorValid(options.backgroundColor)) {\n    throw new Error(`${options.backgroundColor} is not a valid backgroundColor`);\n  }\n\n  const chars = getBorderChars(options.borderStyle);\n  const padding = getObject(options.padding);\n  const margin = getObject(options.margin);\n\n  const colorizeBorder = border => {\n    const newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;\n    return options.dimBorder ? chalk.dim(newBorder) : newBorder;\n  };\n\n  const colorizeContent = content => options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;\n\n  text = ansiAlign(text, {\n    align: options.align\n  });\n  const NL = '\\n';\n  const PAD = ' ';\n  let lines = text.split(NL);\n\n  if (padding.top > 0) {\n    lines = new Array(padding.top).fill('').concat(lines);\n  }\n\n  if (padding.bottom > 0) {\n    lines = lines.concat(new Array(padding.bottom).fill(''));\n  }\n\n  const contentWidth = widestLine(text) + padding.left + padding.right;\n  const paddingLeft = PAD.repeat(padding.left);\n  const {\n    columns\n  } = termSize();\n  let marginLeft = PAD.repeat(margin.left);\n\n  if (options.float === 'center') {\n    const padWidth = Math.max((columns - contentWidth) / 2, 0);\n    marginLeft = PAD.repeat(padWidth);\n  } else if (options.float === 'right') {\n    const padWidth = Math.max(columns - contentWidth - margin.right - 2, 0);\n    marginLeft = PAD.repeat(padWidth);\n  }\n\n  const horizontal = chars.horizontal.repeat(contentWidth);\n  const top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + horizontal + chars.topRight);\n  const bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));\n  const side = colorizeBorder(chars.vertical);\n  const middle = lines.map(line => {\n    const paddingRight = PAD.repeat(contentWidth - stringWidth(line) - padding.left);\n    return marginLeft + side + colorizeContent(paddingLeft + line + paddingRight) + side;\n  }).join(NL);\n  return top + NL + middle + NL + bottom;\n};\n\nmodule.exports._borderStyles = cliBoxes;","map":{"version":3,"sources":["C:/Users/anafe/OneDrive/Documentos/projeto_com_react2/src/backend/node/node_modules/boxen/index.js"],"names":["stringWidth","require","chalk","widestLine","cliBoxes","camelCase","ansiAlign","termSize","getObject","detail","object","top","right","bottom","left","getBorderChars","borderStyle","sides","chararacters","TypeError","side","isHex","color","match","isColorValid","getColorFn","hex","getBGColorFn","bgHex","module","exports","text","options","padding","dimBorder","align","float","borderColor","Error","backgroundColor","chars","margin","colorizeBorder","border","newBorder","dim","colorizeContent","content","NL","PAD","lines","split","Array","fill","concat","contentWidth","paddingLeft","repeat","columns","marginLeft","padWidth","Math","max","horizontal","topLeft","topRight","bottomLeft","bottomRight","vertical","middle","map","line","paddingRight","join","_borderStyles"],"mappings":"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","sourcesContent":["'use strict';\nconst stringWidth = require('string-width');\nconst chalk = require('chalk');\nconst widestLine = require('widest-line');\nconst cliBoxes = require('cli-boxes');\nconst camelCase = require('camelcase');\nconst ansiAlign = require('ansi-align');\nconst termSize = require('term-size');\n\nconst getObject = detail => {\n\tlet object;\n\n\tif (typeof detail === 'number') {\n\t\tobject = {\n\t\t\ttop: detail,\n\t\t\tright: detail * 3,\n\t\t\tbottom: detail,\n\t\t\tleft: detail * 3\n\t\t};\n\t} else {\n\t\tobject = {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0,\n\t\t\t...detail\n\t\t};\n\t}\n\n\treturn object;\n};\n\nconst getBorderChars = borderStyle => {\n\tconst sides = [\n\t\t'topLeft',\n\t\t'topRight',\n\t\t'bottomRight',\n\t\t'bottomLeft',\n\t\t'vertical',\n\t\t'horizontal'\n\t];\n\n\tlet chararacters;\n\n\tif (typeof borderStyle === 'string') {\n\t\tchararacters = cliBoxes[borderStyle];\n\n\t\tif (!chararacters) {\n\t\t\tthrow new TypeError(`Invalid border style: ${borderStyle}`);\n\t\t}\n\t} else {\n\t\tfor (const side of sides) {\n\t\t\tif (!borderStyle[side] || typeof borderStyle[side] !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid border style: ${side}`);\n\t\t\t}\n\t\t}\n\n\t\tchararacters = borderStyle;\n\t}\n\n\treturn chararacters;\n};\n\nconst isHex = color => color.match(/^#[0-f]{3}(?:[0-f]{3})?$/i);\nconst isColorValid = color => typeof color === 'string' && ((chalk[color]) || isHex(color));\nconst getColorFn = color => isHex(color) ? chalk.hex(color) : chalk[color];\nconst getBGColorFn = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];\n\nmodule.exports = (text, options) => {\n\toptions = {\n\t\tpadding: 0,\n\t\tborderStyle: 'single',\n\t\tdimBorder: false,\n\t\talign: 'left',\n\t\tfloat: 'left',\n\t\t...options\n\t};\n\n\tif (options.borderColor && !isColorValid(options.borderColor)) {\n\t\tthrow new Error(`${options.borderColor} is not a valid borderColor`);\n\t}\n\n\tif (options.backgroundColor && !isColorValid(options.backgroundColor)) {\n\t\tthrow new Error(`${options.backgroundColor} is not a valid backgroundColor`);\n\t}\n\n\tconst chars = getBorderChars(options.borderStyle);\n\tconst padding = getObject(options.padding);\n\tconst margin = getObject(options.margin);\n\n\tconst colorizeBorder = border => {\n\t\tconst newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;\n\t\treturn options.dimBorder ? chalk.dim(newBorder) : newBorder;\n\t};\n\n\tconst colorizeContent = content => options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;\n\n\ttext = ansiAlign(text, {align: options.align});\n\n\tconst NL = '\\n';\n\tconst PAD = ' ';\n\n\tlet lines = text.split(NL);\n\n\tif (padding.top > 0) {\n\t\tlines = new Array(padding.top).fill('').concat(lines);\n\t}\n\n\tif (padding.bottom > 0) {\n\t\tlines = lines.concat(new Array(padding.bottom).fill(''));\n\t}\n\n\tconst contentWidth = widestLine(text) + padding.left + padding.right;\n\tconst paddingLeft = PAD.repeat(padding.left);\n\tconst {columns} = termSize();\n\tlet marginLeft = PAD.repeat(margin.left);\n\n\tif (options.float === 'center') {\n\t\tconst padWidth = Math.max((columns - contentWidth) / 2, 0);\n\t\tmarginLeft = PAD.repeat(padWidth);\n\t} else if (options.float === 'right') {\n\t\tconst padWidth = Math.max(columns - contentWidth - margin.right - 2, 0);\n\t\tmarginLeft = PAD.repeat(padWidth);\n\t}\n\n\tconst horizontal = chars.horizontal.repeat(contentWidth);\n\tconst top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + horizontal + chars.topRight);\n\tconst bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));\n\tconst side = colorizeBorder(chars.vertical);\n\n\tconst middle = lines.map(line => {\n\t\tconst paddingRight = PAD.repeat(contentWidth - stringWidth(line) - padding.left);\n\t\treturn marginLeft + side + colorizeContent(paddingLeft + line + paddingRight) + side;\n\t}).join(NL);\n\n\treturn top + NL + middle + NL + bottom;\n};\n\nmodule.exports._borderStyles = cliBoxes;\n"]},"metadata":{},"sourceType":"module"}